<!DOCTYPE html>
<!-- saved from url=(0098)https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml -->
<html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="4127660" data-user-uuid="b28f9685-65fa-4f95-827a-bc87c37860af" data-username="chenshangwen" data-account-type="Trial" data-activated-trial-date="01/21/2019" data-archive="9781482229417" data-publishers="A K Peters/CRC Press" data-htmlfile-name="K22616_C003.xhtml" data-epub-title="Fundamentals of Computer Graphics, 4th Edition" data-debug="0" data-testing="0" style=""><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9781482229417"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/munchkin.js.download"></script><script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/1732687426968531" async=""></script><script async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fbevents.js.download"></script><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/bat.js.download"></script><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/linkid.js.download"></script><script async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/gtm.js.download"></script><script async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/analytics.js.download"></script><script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,n,t){function r(t){if(!n[t]){var o=n[t]={exports:{}};e[t][0].call(o.exports,function(n){var o=e[t][1][n];return r(o||n)},o,o.exports)}return n[t].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<t.length;o++)r(t[o]);return r}({1:[function(e,n,t){function r(){}function o(e,n,t){return function(){return i(e,[c.now()].concat(u(arguments)),n?null:this,t),n?void 0:this}}var i=e("handle"),a=e(3),u=e(4),f=e("ee").get("tracer"),c=e("loader"),s=NREUM;"undefined"==typeof window.newrelic&&(newrelic=s);var p=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],d="api-",l=d+"ixn-";a(p,function(e,n){s[n]=o(d+n,!0,"api")}),s.addPageAction=o(d+"addPageAction",!0),s.setCurrentRouteName=o(d+"routeName",!0),n.exports=newrelic,s.interaction=function(){return(new r).get()};var m=r.prototype={createTracer:function(e,n){var t={},r=this,o="function"==typeof n;return i(l+"tracer",[c.now(),e,t],r),function(){if(f.emit((o?"":"no-")+"fn-start",[c.now(),r,o],t),o)try{return n.apply(this,arguments)}catch(e){throw f.emit("fn-err",[arguments,this,e],t),e}finally{f.emit("fn-end",[c.now()],t)}}}};a("actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(e,n){m[n]=o(l+n)}),newrelic.noticeError=function(e,n){"string"==typeof e&&(e=new Error(e)),i("err",[e,c.now(),!1,n])}},{}],2:[function(e,n,t){function r(e,n){if(!o)return!1;if(e!==o)return!1;if(!n)return!0;if(!i)return!1;for(var t=i.split("."),r=n.split("."),a=0;a<r.length;a++)if(r[a]!==t[a])return!1;return!0}var o=null,i=null,a=/Version\/(\S+)\s+Safari/;if(navigator.userAgent){var u=navigator.userAgent,f=u.match(a);f&&u.indexOf("Chrome")===-1&&u.indexOf("Chromium")===-1&&(o="Safari",i=f[1])}n.exports={agent:o,version:i,match:r}},{}],3:[function(e,n,t){function r(e,n){var t=[],r="",i=0;for(r in e)o.call(e,r)&&(t[i]=n(r,e[r]),i+=1);return t}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],4:[function(e,n,t){function r(e,n,t){n||(n=0),"undefined"==typeof t&&(t=e?e.length:0);for(var r=-1,o=t-n||0,i=Array(o<0?0:o);++r<o;)i[r]=e[n+r];return i}n.exports=r},{}],5:[function(e,n,t){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],ee:[function(e,n,t){function r(){}function o(e){function n(e){return e&&e instanceof r?e:e?f(e,u,i):i()}function t(t,r,o,i){if(!d.aborted||i){e&&e(t,r,o);for(var a=n(o),u=v(t),f=u.length,c=0;c<f;c++)u[c].apply(a,r);var p=s[y[t]];return p&&p.push([b,t,r,a]),a}}function l(e,n){h[e]=v(e).concat(n)}function m(e,n){var t=h[e];if(t)for(var r=0;r<t.length;r++)t[r]===n&&t.splice(r,1)}function v(e){return h[e]||[]}function g(e){return p[e]=p[e]||o(t)}function w(e,n){c(e,function(e,t){n=n||"feature",y[t]=n,n in s||(s[n]=[])})}var h={},y={},b={on:l,addEventListener:l,removeEventListener:m,emit:t,get:g,listeners:v,context:n,buffer:w,abort:a,aborted:!1};return b}function i(){return new r}function a(){(s.api||s.feature)&&(d.aborted=!0,s=d.backlog={})}var u="nr@context",f=e("gos"),c=e(3),s={},p={},d=n.exports=o();d.backlog=s},{}],gos:[function(e,n,t){function r(e,n,t){if(o.call(e,n))return e[n];var r=t();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return e[n]=r,r}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(e,n,t){function r(e,n,t,r){o.buffer([e],r),o.emit(e,n,t)}var o=e("ee").get("handle");n.exports=r,r.ee=o},{}],id:[function(e,n,t){function r(e){var n=typeof e;return!e||"object"!==n&&"function"!==n?-1:e===window?0:a(e,i,function(){return o++})}var o=1,i="nr@id",a=e("gos");n.exports=r},{}],loader:[function(e,n,t){function r(){if(!E++){var e=x.info=NREUM.info,n=l.getElementsByTagName("script")[0];if(setTimeout(s.abort,3e4),!(e&&e.licenseKey&&e.applicationID&&n))return s.abort();c(y,function(n,t){e[n]||(e[n]=t)}),f("mark",["onload",a()+x.offset],null,"api");var t=l.createElement("script");t.src="https://"+e.agent,n.parentNode.insertBefore(t,n)}}function o(){"complete"===l.readyState&&i()}function i(){f("mark",["domContent",a()+x.offset],null,"api")}function a(){return O.exists&&performance.now?Math.round(performance.now()):(u=Math.max((new Date).getTime(),u))-x.offset}var u=(new Date).getTime(),f=e("handle"),c=e(3),s=e("ee"),p=e(2),d=window,l=d.document,m="addEventListener",v="attachEvent",g=d.XMLHttpRequest,w=g&&g.prototype;NREUM.o={ST:setTimeout,SI:d.setImmediate,CT:clearTimeout,XHR:g,REQ:d.Request,EV:d.Event,PR:d.Promise,MO:d.MutationObserver};var h=""+location,y={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1118.min.js"},b=g&&w&&w[m]&&!/CriOS/.test(navigator.userAgent),x=n.exports={offset:u,now:a,origin:h,features:{},xhrWrappable:b,userAgent:p};e(1),l[m]?(l[m]("DOMContentLoaded",i,!1),d[m]("load",r,!1)):(l[v]("onreadystatechange",o),d[v]("onload",r)),f("mark",["firstbyte",u],null,"api");var E=0,O=e(5)},{}]},{},["loader"]);</script><link rel="apple-touch-icon" href="https://learning.oreilly.com/static/images/apple-touch-icon.0c29511d2d72.png"><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/css" rel="stylesheet" type="text/css"><title>Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition</title><link rel="stylesheet" href="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/1282215c62d0.css" type="text/css"><link rel="stylesheet" type="text/css" href="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/annotator.e3b0c44298fc.css"><link rel="stylesheet" href="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/font-awesome.min.css"><style type="text/css" title="ibis-book">@font-face{font-family:"Helvetica LT Std Black";font-style:normal;font-weight:bold;src:url(../font/HelveticaLTStd-Blk.otf)}@font-face{font-family:"Helvetica LT Std Bold";font-style:normal;font-weight:bold;src:url(../font/HelveticaLTStd-Bold.otf)}@font-face{font-family:"Helvetica LT Std Bold Oblique";font-style:italic;font-weight:bold;src:url(../font/HelveticaLTStd-BoldObl.otf)}@font-face{font-family:"Helvetica LT Std Oblique";font-style:italic;font-weight:normal;src:url(../font/HelveticaLTStd-Obl.otf)}@font-face{font-family:"Helvetica LT Std";font-style:normal;font-weight:normal;src:url(../font/HelveticaLTStd-Roman.otf)}@font-face{font-family:"Myriad Pro";font-style:normal;font-weight:normal;src:url(../font/MyriadPro-Regular.otf)}@font-face{font-family:"STIX General";font-style:normal;font-weight:normal;src:url(../font/STIXGeneral.otf)}@font-face{font-family:"STIX General Bold";font-style:normal;font-weight:bold;src:url(../font/STIXGeneralBol.otf)}@font-face{font-family:"STIX General Bold Italic";font-style:italic;font-weight:bold;src:url(../font/STIXGeneralBolIta.otf)}@font-face{font-family:"STIX General Italic";font-style:italic;font-weight:normal;src:url(../font/STIXGeneralItalic.otf)}@font-face{font-family:"Times LT Std Bold";font-style:normal;font-weight:bold;src:url(../font/TimesLTStd-Bold.otf)}@font-face{font-family:"Times LT Std Bold Italic";font-style:italic;font-weight:bold;src:url(../font/TimesLTStd-BoldItalic.otf)}@font-face{font-family:"Times LT Std Italic";font-style:italic;font-weight:normal;src:url(../font/TimesLTStd-Italic.otf)}@font-face{font-family:"Times LT Std";font-style:normal;font-weight:normal;src:url(../font/TimesLTStd-Roman.otf)}#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content p,#sbo-rt-content .figcaption{-epub-hyphens:auto;background-color:inherit;border:none;border-width:0;break-after:auto;break-before:auto;break-inside:auto;color:black;display:block;float:none;font-family:"Times LT Std","STIX General","Adobe Caslon Pro",serif;font-size:1em;font-style:normal;font-weight:normal;font-size-adjust:none;font-stretch:normal;hanging-punctuation:none;letter-spacing:0;line-height:1.25em;margin-bottom:0;margin-left:2px;margin-right:2px;margin-top:0;orphans:2;overflow:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;text-align:justify;text-align-last:left;text-decoration:none;text-shadow:none;text-indent:0;text-justify:distribute;text-transform:none;vertical-align:baseline;white-space:normal;widows:2;word-spacing:normal}#sbo-rt-content blockquote,#sbo-rt-content q{-epub-hyphens:auto;background-color:inherit;border:none;border-width:0;break-after:auto;break-before:auto;break-inside:avoid;color:black;display:block;float:none;font-family:"Adobe Caslon Pro",san-serif;font-size:1em;font-style:normal;font-weight:normal;font-size-adjust:none;font-stretch:normal;hanging-punctuation:none;letter-spacing:0;line-height:1.2em;margin-bottom:0;margin-left:5%;margin-right:5%;margin-top:.75em;orphans:4;overflow:scroll;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:avoid;text-align:justify;text-align-last:left;text-decoration:none;text-shadow:none;text-indent:0;text-justify:distribute;text-transform:none;vertical-align:baseline;white-space:normal;widows:4;word-spacing:normal}#sbo-rt-content pre{-epub-hyphens:none;background-color:Azure;border:none;border-width:0;break-after:auto;break-before:auto;break-inside:avoid;color:black;display:block;float:none;font-family:"Courier Std","STIX General",monospaced;font-size:.95em;font-style:normal;font-weight:normal;font-size-adjust:.58;font-stretch:normal;hanging-punctuation:none;letter-spacing:0;line-height:1.2em;margin-bottom:.75em;margin-left:2px;margin-right:2px;margin-top:.75em;orphans:6;overflow:scroll;padding-bottom:.25em;padding-left:.25em;padding-right:.25em;padding-top:.45em;page-break-after:avoid;page-break-before:auto;page-break-inside:avoid;text-align:left;text-align-last:left;text-decoration:none;text-shadow:none;text-indent:0;text-justify:inter-word;text-transform:none;vertical-align:baseline;white-space:normal;widows:6;word-spacing:normal}#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p.h1Number,#sbo-rt-content .h1Author,#sbo-rt-content .h2Author,#sbo-rt-content .h3Author,#sbo-rt-content .h4Author,#sbo-rt-content .h5Author,#sbo-rt-content .h6Author,#sbo-rt-content .h1sub{-epub-hyphens:none;background-color:inherit;border:none;border-width:0;break-after:avoid;break-before:auto;break-inside:avoid;color:DarkGreen;display:block;float:none;font-family:"Times LT Std","STIX General","Adobe Caslon Pro",serif;font-size:1em;font-style:normal;font-weight:bold;font-size-adjust:none;font-stretch:normal;hanging-punctuation:none;letter-spacing:0;line-height:1.2em;margin-bottom:.1em;margin-left:2px;margin-right:2px;margin-top:1em;orphans:6;overflow:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:avoid;page-break-before:auto;page-break-inside:avoid;text-align:left;text-align-last:left;text-decoration:none;text-shadow:none;text-indent:0;text-justify:inter-word;text-transform:none;vertical-align:baseline;white-space:normal;widows:6;word-break:keep-all;word-spacing:normal}#sbo-rt-content h1{font-size:2em;margin-top:.5em}#sbo-rt-content p.h1sub{font-size:1.75em;font-style:italic}#sbo-rt-content h2{font-size:1.8em}#sbo-rt-content h3{font-size:1.5em}#sbo-rt-content h4{font-size:1.2em}#sbo-rt-content h5{font-size:1em}#sbo-rt-content h6{font-size:1em;font-style:italic}#sbo-rt-content .h1Author{color:black;font-size:1.75em;font-weight:normal;font-style:italic}#sbo-rt-content .h2Author{color:black;font-size:1.4em;font-weight:normal;font-style:italic}#sbo-rt-content .h3Author{color:black;font-size:1.2em;font-weight:normal;font-style:italic}#sbo-rt-content .h4Author{color:black;font-size:1em;font-weight:normal;font-style:italic}#sbo-rt-content .h5Author{color:black;font-size:1em;font-weight:normal;font-style:italic}#sbo-rt-content .h6Author{color:black;font-size:.8em;font-weight:normal;font-style:normal}#sbo-rt-content .h1Affiliation,#sbo-rt-content .h2Affiliation,#sbo-rt-content .h3Affiliation,#sbo-rt-content .h4Affiliation,#sbo-rt-content .h5Affiliation,#sbo-rt-content .h6Affiliation{-epub-hyphens:none;background-color:inherit;border:none;border-width:0;break-after:avoid;break-before:auto;break-inside:avoid;color:black;display:block;float:none;font-family:"Times LT Std","STIX General","Adobe Caslon Pro",serif;font-size:1em;font-style:normal;font-weight:normal;font-size-adjust:none;font-stretch:normal;hanging-punctuation:none;letter-spacing:0;line-height:1.2em;margin-bottom:.5em;margin-left:2px;margin-right:2px;margin-top:0;orphans:6;overflow:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:avoid;page-break-before:auto;page-break-inside:avoid;text-align:left;text-align-last:left;text-decoration:none;text-shadow:none;text-indent:0;text-justify:inter-word;text-transform:none;vertical-align:baseline;white-space:normal;widows:6;word-spacing:normal}#sbo-rt-content .h1Affiliation{color:black;font-size:1.55em}#sbo-rt-content .h2Affiliation{color:black;font-size:1.2em}#sbo-rt-content .h3Affiliation{color:black;font-size:1em}#sbo-rt-content .h4Affiliation{color:black;font-size:.9em}#sbo-rt-content .h5Affiliation{color:black;font-size:.8em}#sbo-rt-content .h6Affiliation{color:black;font-size:.8em}#sbo-rt-content .textAuthor{font-weight:bold;text-align:right}#sbo-rt-content .textAffiliation{font-style:italic;text-align:right;margin-bottom:.5em}#sbo-rt-content Allitross{font-family:monospace;font-size:4em;color:red;background-color:yellow;line-height:8em}#sbo-rt-content q{font-style:italic}#sbo-rt-content p{margin-top:1.2em;text-indent:.75em}#sbo-rt-content table{border-collapse:collapse;margin-bottom:.25em;margin-top:.25em}#sbo-rt-content thead{background-color:#0C6}#sbo-rt-content tr{background-color:inherit;border-bottom:thin dotted lightgrey;border-top:thin dotted lightgrey}#sbo-rt-content td{padding:2px 4px 2px 4px}#sbo-rt-content thead>tr{border:none}#sbo-rt-content thead>tr:last-child{border-bottom:thin solid DarkGreen}#sbo-rt-content img{height:auto;width:75%}#sbo-rt-content div.ArtGroup{border-bottom:thin solid DarkGreen;border-top:thin solid DarkGreen;break-inside:avoid;margin-bottom:.25em;margin-top:.25em;overflow:scroll;page-break-inside:avoid;width:100%}#sbo-rt-content div.Table{overflow:scroll;width:100%}#sbo-rt-content div.Box{border:black solid 2px;margin-bottom:2%;margin-left:3%;margin-right:3%;margin-top:2%;padding-bottom:1%;padding-left:3%;padding-right:3%;padding-top:1%;page-break-inside:avoid}#sbo-rt-content div.Shaded{background-color:silver}#sbo-rt-content .footer{page-break-inside:auto;text-align:center;text-align-last:center;text-decoration:none;text-shadow:none;text-indent:0;text-justify:distribute;text-transform:none;vertical-align:baseline;white-space:normal;widows:6;word-spacing:normal}#sbo-rt-content .Example{font-family:"Helvetica LT Std",sans-serif;margin-left:3%;margin-right:3%;margin-top:1em}#sbo-rt-content h1.Example,#sbo-rt-content h1.Extract,#sbo-rt-content h1.Vignette,#sbo-rt-content h1.Math,#sbo-rt-content h1.Problems,#sbo-rt-content h1.GC1,#sbo-rt-content h1.GC2,#sbo-rt-content h1.GC3,#sbo-rt-content h1.GC4{font-size:1.8em}#sbo-rt-content h2.Example,#sbo-rt-content h2.Extract,#sbo-rt-content h2.Vignette,#sbo-rt-content h2.Math,#sbo-rt-content h2.Problems,#sbo-rt-content h2.GC1,#sbo-rt-content h2.GC2,#sbo-rt-content h2.GC3,#sbo-rt-content h2.GC4{font-size:1.5em}#sbo-rt-content h3.Example,#sbo-rt-content h3.Extract,#sbo-rt-content h3.Vignette,#sbo-rt-content h3.Math,#sbo-rt-content h3.Problems,#sbo-rt-content h3.GC1,#sbo-rt-content h3.GC2,#sbo-rt-content h3.GC3,#sbo-rt-content h3.GC4{font-size:1.2em}#sbo-rt-content h4.Example,#sbo-rt-content h4.Extract,#sbo-rt-content h4.Vignette,#sbo-rt-content h4.Math,#sbo-rt-content h4.Problems,#sbo-rt-content h4.GC1,#sbo-rt-content h4.GC2,#sbo-rt-content h4.GC3,#sbo-rt-content h4.GC4{font-size:1em}#sbo-rt-content .Table{background-color:transparent;font-family:"Helvetica LT Std",sans-serif;font-size:85%}#sbo-rt-content .Extract{font-family:"Helvetica LT Std",sans-serif;font-size:88%;line-height:1em;margin-left:2%;margin-right:2%;margin-top:1em}#sbo-rt-content .Vignette{margin-right:2%;margin-left:2%}#sbo-rt-content .GC1{background-color:powderblue}#sbo-rt-content .GC2{background-color:oldlace}#sbo-rt-content .GC3{background-color:lightgrey}#sbo-rt-content .GC4{background-color:lightblue}#sbo-rt-content .Sidebar{font-size:75%}#sbo-rt-content .BookTitle{-epub-hyphens:none;font-size:2.5em;font-weight:bold;margin-left:10%;margin-right:10%;margin-top:10%;text-align:center}#sbo-rt-content .BookSubTitle{-epub-hyphens:none;font-size:2em;font-style:italic;font-weight:bold;margin-left:10%;margin-right:10%;text-align:center}#sbo-rt-content .BookAuthor{-epub-hyphens:none;font-size:1.5em;font-weight:bold;margin-left:10%;margin-right:10%;margin-top:10%;text-align:center}#sbo-rt-content .BookAuthorAffiliation{-epub-hyphens:none;font-size:1em;font-style:italic;margin-left:10%;margin-right:10%;text-align:center}#sbo-rt-content .BookLogo{margin-top:1em;text-align:center;page-break-after:always}#sbo-rt-content .CIP1{font-family:"Helvetica LT Std",sans-serif;font-size:75%}#sbo-rt-content .CIP2{font-family:"Helvetica LT Std",sans-serif;font-size:75%;margin-top:.75em}#sbo-rt-content .Speaker{margin-top:.75em}#sbo-rt-content .Equation{line-height:3em;text-align:center}#sbo-rt-content .fignumber{display:inline;background-color:darkgreen;color:white;margin:.5em;padding-bottom:.25em;padding-left:.5em;padding-right:.5em;padding-top:.35em;break-after:avoid;font-size:1em;font-weight:bold;page-break-after:avoid;page-break-before:avoid}#sbo-rt-content .figcaption{break-after:avoid;break-before:avoid;font-size:.85em;margin-left:4px;margin-right:4px;page-break-after:avoid;page-break-before:avoid}#sbo-rt-content .figsource{break-before:avoid;font-size:.85em;font-style:italic;margin-left:4px;margin-right:4px;page-break-before:avoid}#sbo-rt-content .ObjectLine{margin-bottom:6px;margin-top:6px;text-align:center}#sbo-rt-content .footnote{font-size:80%;margin-left:1%;margin-right:2%;text-indent:0}#sbo-rt-content .GlossTerm{font-weight:bold;margin-left:1em;margin-top:.5em}#sbo-rt-content .GlossDef{margin-left:1em}#sbo-rt-content .Float{float:right}#sbo-rt-content .Left{float:left}#sbo-rt-content .NoteHead{font-weight:bold}#sbo-rt-content .RF{margin-left:.5em;margin-top:.3em;text-indent:0}#sbo-rt-content .RF1{margin-left:.75em;margin-top:.3em;text-indent:0}#sbo-rt-content .RF2{margin-left:1.25em;margin-top:.3em;text-indent:0}#sbo-rt-content h1+p,#sbo-rt-content h2+p,#sbo-rt-content h3+p,#sbo-rt-content h4+p,#sbo-rt-content h5+p,#sbo-rt-content h6+p,#sbo-rt-content p.Number+p,#sbo-rt-content td>p:first-child{margin-top:0;text-indent:0}#sbo-rt-content .Equation+p{text-indent:0}#sbo-rt-content h1+h1,#sbo-rt-content h1+h3,#sbo-rt-content h1+h4,#sbo-rt-content h1+h5,#sbo-rt-content h1+h6,#sbo-rt-content h2+h2,#sbo-rt-content h2+h4,#sbo-rt-content h2+h5,#sbo-rt-content h2+h6,#sbo-rt-content h3+h3,#sbo-rt-content h3+h5,#sbo-rt-content h3+h6,#sbo-rt-content h4+h4,#sbo-rt-content h4+h6,#sbo-rt-content h5+h5,#sbo-rt-content h6+h6,#sbo-rt-content p.h1sub+p.h1sub,#sbo-rt-content p.Number+p.Number{background-color:Yellow;color:Red;line-height:8em;margin-top:0}#sbo-rt-content h1+p.h1sub,#sbo-rt-content h1+h2,#sbo-rt-content p.h1sub+h2,#sbo-rt-content h2+h3,#sbo-rt-content h3+h4,#sbo-rt-content h4+h5,#sbo-rt-content h5+h6,#sbo-rt-content p+p,#sbo-rt-content blockquote.textAuthor+blockquote.textAffiliation,#sbo-rt-content p.Speaker+p.Speaker{margin-top:0}#sbo-rt-content h1+p.h1Author,#sbo-rt-content h2+p.h2Author,#sbo-rt-content h3+p.h3Author,#sbo-rt-content h4+p.h4Author,#sbo-rt-content h5+p.h5Author,#sbo-rt-content h6+p.h6Author{margin-top:0}#sbo-rt-content p.h1Author+p.h1Affiliation,#sbo-rt-content p.h2Author+p.h2Affiliation,#sbo-rt-content p.h3Author+p.h3Affiliation,#sbo-rt-content p.h4Author+p.h4Affiliation,#sbo-rt-content p.h5Author+p.h5Affiliation,#sbo-rt-content p.h6Author+p.h6Affiliation{color:grey;margin-top:0}#sbo-rt-content p.h1Affiliation+p,#sbo-rt-content p.h2Affiliation+p,#sbo-rt-content p.h3Affiliation+p,#sbo-rt-content p.h4Affiliation+p,#sbo-rt-content p.h5Affiliation+p,#sbo-rt-content p.h6Affiliation+p{margin-top:0;text-indent:0}#sbo-rt-content .Extract+.Extract,#sbo-rt-content .Example+.Example{margin-top:0}#sbo-rt-content .Extract+.Dictionary,#sbo-rt-content .Extract+.Example,#sbo-rt-content .Extract+.GC1,#sbo-rt-content .Extract+.GC2,#sbo-rt-content .Extract+.GC3,#sbo-rt-content .Extract+.GC4,#sbo-rt-content .Extract+.Text,#sbo-rt-content .Extract+.Math,#sbo-rt-content .Extract+.Problem,#sbo-rt-content .Dictionary+.Extract,#sbo-rt-content .Example+.Extract,#sbo-rt-content .GC1+.Extract,#sbo-rt-content .GC2+.Extract,#sbo-rt-content .GC3+.Extract,#sbo-rt-content .GC4+.Extract,#sbo-rt-content .Text+.Extract,#sbo-rt-content .Math+.Extract,#sbo-rt-content .Problem+.Extract{margin-top:1em;text-indent:0}#sbo-rt-content .Example+.Dictionary,#sbo-rt-content .Example+.Extract,#sbo-rt-content .Example+.GC1,#sbo-rt-content .Example+.GC2,#sbo-rt-content .Example+.GC3,#sbo-rt-content .Example+.GC4,#sbo-rt-content .Example+.Text,#sbo-rt-content .Example+.Math,#sbo-rt-content .Example+.Problem,#sbo-rt-content .Dictionary+.Example,#sbo-rt-content .Extract+.Example,#sbo-rt-content .GC1+.Example,#sbo-rt-content .GC2+.Example,#sbo-rt-content .GC3+.Example,#sbo-rt-content .GC4+.Example,#sbo-rt-content .Text+.Example,#sbo-rt-content .Math+.Example,#sbo-rt-content .Problem+.Example{margin-top:1em;text-indent:0}#sbo-rt-content .Dictionary+.Vignette,#sbo-rt-content .Example+.Vignette,#sbo-rt-content .Extract+.Vignette,#sbo-rt-content .GC1+.Vignette,#sbo-rt-content .GC2+.Vignette,#sbo-rt-content .GC3+.Vignette,#sbo-rt-content .GC4+.Vignette,#sbo-rt-content .Text+.Vignette,#sbo-rt-content .Math+.Vignette,#sbo-rt-content .Problem+.Vignette{border-top:black thin solid;margin-top:1em}#sbo-rt-content .Vignette+.Dictionary,#sbo-rt-content .Vignette+.Example,#sbo-rt-content .Vignette+.Extract,#sbo-rt-content .Vignette+.GC1,#sbo-rt-content .Vignette+.GC2,#sbo-rt-content .Vignette+.GC3,#sbo-rt-content .Vignette+.GC4,#sbo-rt-content .Vignette+.Text,#sbo-rt-content .Vignette+.Math,#sbo-rt-content .Vignette+.Problem{border-top:black thin solid;margin-top:1em}#sbo-rt-content span.cBold,#sbo-rt-content span.c75Bold{font-weight:bold}#sbo-rt-content span.cSubscript{font-size:82%;line-height:1em;vertical-align:sub}#sbo-rt-content span.cSuperscript{font-size:82%;line-height:1em;vertical-align:super}#sbo-rt-content span.cBI{font-style:italic;font-weight:bold}#sbo-rt-content span.cAllCaps{text-transform:uppercase}#sbo-rt-content span.cBIsub{font-size:82%;font-style:italic;font-weight:bold;line-height:1em;vertical-align:sub}#sbo-rt-content span.cBIsup{font-size:82%;font-style:italic;font-weight:bold;line-height:1em;vertical-align:super}#sbo-rt-content span.cBoldsub,#sbo-rt-content span.cBsub{font-size:82%;font-weight:bold;line-height:1em;vertical-align:sub}#sbo-rt-content span.cBoldsup,#sbo-rt-content span.cBsup{font-size:82%;font-weight:bold;line-height:1em;vertical-align:super}#sbo-rt-content span.cColor{color:darkblue}#sbo-rt-content span.cMagenta{color:magenta}#sbo-rt-content span.cDSP,#sbo-rt-content span.code{-epub-hyphens:none;background-color:Azure;font-family:"Courier Std","STIX General",monospaced;font-size:.95em;font-style:normal;font-weight:normal;font-size-adjust:.58}#sbo-rt-content span.cIsub{font-size:82%;font-style:italic;line-height:1em;vertical-align:sub}#sbo-rt-content span.cIsup{font-size:82%;font-style:italic;line-height:1em;vertical-align:super}#sbo-rt-content span.cItalic,#sbo-rt-content span.cVariable{font-style:italic}#sbo-rt-content span.cOverbar{border-top:solid 1px}#sbo-rt-content span.cSmCap{font-variant:small-caps}#sbo-rt-content span.cSymGreek,#sbo-rt-content span.cSymMath{font-family:"STIX General",serif}#sbo-rt-content span.cSymGreekBI{font-family:"STIX General",serif;font-style:italic;font-weight:bold}#sbo-rt-content span.cSymGreekBold{font-family:"STIX General",serif;font-weight:bold}#sbo-rt-content span.cSymGreekItalic{font-family:"STIX General",serif;font-style:italic}#sbo-rt-content span.cUnderline{border-bottom:solid 1px}#sbo-rt-content .application{font-size:85%;text-transform:uppercase}#sbo-rt-content .class{color:blue;font-style:italic}#sbo-rt-content .command{color:navy;font-weight:bold}#sbo-rt-content .comment{color:darkgrey}#sbo-rt-content .enumeration{color:purple;font-style:italic}#sbo-rt-content .function{font-style:italic}#sbo-rt-content .keywords{font-weight:bold}#sbo-rt-content .property{color:purple}#sbo-rt-content p.h1Number{border-bottom:1px solid black;color:black;font-size:1.65em;overflow:visible}#sbo-rt-content p.centerHead{font-weight:Bold;text-align:center}#sbo-rt-content p.leftHead{font-weight:Bold;text-align:left}#sbo-rt-content p.rightHead{font-weight:Bold;text-align:right}#sbo-rt-content p.tableTitle{font-size:110%;line-height:110%;font-weight:bold;text-indent:0}#sbo-rt-content p.tableNumber{font-size:110%;line-height:110%;font-weight:bold;text-indent:0}#sbo-rt-content .GlossTerm::after{content:": "}#sbo-rt-content math{font-family:"STIX General",serif}</style><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9781482229417/chapter/K22616_C003.xhtml",
          "book_id": "9781482229417",
          "chapter_uri": "K22616_C003.xhtml",
          "position": 0,
          "user_uuid": "b28f9685-65fa-4f95-827a-bc87c37860af",
          "next_chapter_uri": "/library/view/fundamentals-of-computer/9781482229417/K22616_C004.xhtml"
        
      },
      title: "Fundamentals of Computer Graphics, 4th Edition",
      author_list: "Peter Shirley, Steve Marschner",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: true,
      show_ios_app_teaser: false
    };
    // ]]></script><script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/modernizr.8e35451ddb64.js.download"></script><script>
    
      

      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

    
      window.PRIVACY_CONTROL_SWITCH = true;
    

    
      window.PUBLISHER_PAGES = true;
    

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "/api/v2/search/select/",
          "ENABLE_ONLINE_TRAINING": true
        }
      };
  </script><link rel="canonical" href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml"><meta name="description" content="Chapter 3 Raster Images Most computer graphics images are presented to the user on some kind of raster display. Raster displays show images as rectangular arrays of pixels. A common ... "><meta property="og:title" content="Chapter 3 Raster Images"><meta itemprop="isPartOf" content="/library/view/fundamentals-of-computer/9781482229417/"><meta itemprop="name" content="Chapter 3 Raster Images"><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9781482229417/"><meta property="og:description" itemprop="description" content="Chapter 3 Raster Images Most computer graphics images are presented to the user on some kind of raster display. Raster displays show images as rectangular arrays of pixels. A common ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="A K Peters/CRC Press"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9781482229417"><meta property="og:book:author" itemprop="author" content="Peter Shirley"><meta property="og:book:author" itemprop="author" content="Steve Marschner"><meta property="og:book:tag" itemprop="about" content="Digital Media"><meta property="og:book:tag" itemprop="about" content="Engineering"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: &lt;%= font_size %&gt; !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: &lt;%= font_family %&gt; !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: &lt;%= column_width %&gt;% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; url=/library/no-js/" /></noscript><script type="text/javascript">
    (function(i,s,o,g,r,a,m) {
      i['GoogleAnalyticsObject']=r;
      i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();
      a=s.createElement(o),m=s.getElementsByTagName(o)[0];
      a.async=1;
      a.src=g;
      m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    var matches = document.cookie.match(/BrowserCookie\s*=\s*([a-f0-9\-]{36})/),
      user_uuid = null;

    if (matches && matches.length === 2) {
      user_uuid = matches[1];
    }

  
    ga('create', 'UA-39299553-7', {'userId': 'b28f9685-65fa-4f95-827a-bc87c37860af' });
  

  
    
      ga('set', 'dimension1', 'Trial');
    
  

  ga('set', 'dimension6', user_uuid);

  
    ga('set', 'dimension2', 'b28f9685-65fa-4f95-827a-bc87c37860af');
    
  

  

  

  //enable enhanced link tracking
  ga('require', 'linkid', 'linkid.js');

  // reading interface will track pageviews itself
  if (document.location.pathname.indexOf("/library/view") !== 0) {
    ga('send', 'pageview');
  }
  </script><script>
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
  </script><script defer="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/vendor.40e3ab2299ca.js.download"></script><script defer="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/reader.54b3e1936311.js.download"></script><script type="text/javascript" async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/munchkin.js(1).download"></script><script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/f(1).txt"></script><script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/f(2).txt"></script><script async="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/MathJax.js.download"></script><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.1') format('opentype')}
</style><style type="text/css">@font-face {font-family: MathJax_AMS; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_AMS-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_AMS-Regular.otf?V=2.7.1') format('opentype')}
</style><style type="text/css">@font-face {font-family: MathJax_Script; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Script-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Script-Regular.otf?V=2.7.1') format('opentype')}
</style><style type="text/css">@font-face {font-family: MathJax_SansSerif-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Italic.otf?V=2.7.1') format('opentype')}
</style></head>


<body class="reading sidenav  scalefonts subscribe-panel library nav-collapsed"><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

    
  
  <noscript> 
    <iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>
  



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        





<a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://learning.oreilly.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://learning.oreilly.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z"></path></g></svg><span>Recommended</span></a></li><li><a href="https://learning.oreilly.com/playlists/" class="t-queue-nav l0 nav-icn None"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="21px" height="17px" viewBox="0 0 21 17" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --><title>icon_Playlist_sml</title><desc>Created with Sketch.</desc><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="icon_Playlist_sml" fill-rule="nonzero" fill="#000000"><g id="playlist-icon"><g id="Group-6"><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle></g><g id="Group-5" transform="translate(0.000000, 7.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g><g id="Group-5-Copy" transform="translate(0.000000, 14.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g></g></g></g></svg><span>
               Playlists
            </span></a></li><li class="search"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://learning.oreilly.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z"></path></g></svg><span>History</span></a></li><li><a href="https://learning.oreilly.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" width="20" height="20" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z"></path></g></svg><span>Topics</span></a></li><li><a href="https://learning.oreilly.com/learning-paths/" class="l1 nav-icn t-learningpaths-nav js-toggle-menu-item"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="32px" height="32px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 52.5 (67469) - http://www.bohemiancoding.com/sketch --><title>Mask</title><desc>Created with Sketch.</desc><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M0,16.0214227 C0,15.0387209 0.796453294,14.2411658 1.77779753,14.2411658 C2.75914177,14.2411658 3.55559506,15.0387209 3.55559506,16.0214227 C3.55559506,17.0041246 2.75914177,17.8016797 1.77779753,17.8016797 C0.796453294,17.8016797 0,17.0041246 0,16.0214227 Z M9.77788642,5.22914885 C8.9280992,5.72049977 7.84008711,5.42853763 7.34941499,4.57757479 C6.85874287,3.72661195 7.15030167,2.63709467 8.00008889,2.14574375 C8.84987611,1.65439282 9.9378882,1.94635496 10.4285603,2.7973178 C10.9192324,3.64828064 10.6276736,4.73779792 9.77788642,5.22914885 Z M4.57213969,7.35869225 C5.42192691,7.85004318 5.71348571,8.93956046 5.22281359,9.79052329 C4.73214147,10.6414861 3.64412938,10.9334483 2.79434216,10.4420974 C1.94455494,9.95074642 1.65299614,8.86122915 2.14366826,8.01026631 C2.63434038,7.15930347 3.72235247,6.86734132 4.57213969,7.35869225 Z M2.79434216,21.6007481 C3.64412938,21.1093972 4.73214147,21.4013594 5.22281359,22.2523222 C5.71348571,23.103285 5.42192691,24.1928023 4.57213969,24.6841532 C3.72235247,25.1755042 2.63434038,24.883542 2.14366826,24.0325792 C1.65299614,23.1816163 1.94455494,22.0920991 2.79434216,21.6007481 Z M7.34941499,27.4652707 C7.84008711,26.6143079 8.9280992,26.3223457 9.77788642,26.8136966 C10.6276736,27.3050476 10.9192324,28.3945649 10.4285603,29.2455277 C9.9378882,30.0964905 8.84987611,30.3884527 8.00008889,29.8971017 C7.15030167,29.4057508 6.85874287,28.3162335 7.34941499,27.4652707 Z M18.7118524,11.3165596 C21.3074367,12.8173162 22.1963355,16.1392758 20.6976522,18.738451 C19.1989689,21.3358459 15.8815987,22.2259744 13.2860143,20.726998 C10.6922077,19.2262414 9.80330893,15.9042818 11.3002144,13.3051066 C12.7988978,10.7059314 16.116268,9.81580294 18.7118524,11.3165596 Z M26.7821642,27.8093944 L30.1315348,31.1633985 C30.3982044,31.4304371 30.2097579,31.8844026 29.8346426,31.8844026 L21.5945511,31.8844026 C21.1287681,31.8844026 20.751875,31.5069881 20.751875,31.0405608 L20.751875,22.7890697 C20.751875,22.4134355 21.2052134,22.2247282 21.4701052,22.4899865 L24.2843587,25.3081333 C26.8337204,23.0240636 28.4444049,19.7092251 28.4444049,16.0223129 C28.4444049,9.15052091 22.8621207,3.56051397 15.9998222,3.56051397 L15.9998222,0 C24.8230314,0 32,7.18689745 32,16.0223129 C32,20.6919269 29.9750886,24.8790914 26.7821642,27.8093944 Z" id="Mask" fill="#8B889A"></path></g></svg><span>Learning Paths</span></a></li><li class="nav-offers flyout-parent"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>offers icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M35.9 20.6L27 15.5C26.1 15 24.7 15 23.7 15.5L14.9 20.6C13.9 21.1 13.2 22.4 13.2 23.4L13.2 41.4C13.2 42.4 13.9 43.7 14.9 44.2L23.3 49C24.2 49.5 25.6 49.5 26.6 49L35.9 43.6C36.8 43.1 37.6 41.8 37.6 40.8L37.6 23.4C37.6 22.4 36.8 21.1 35.9 20.6L35.9 20.6ZM40 8.2C39.1 7.6 37.6 7.6 36.7 8.2L30.2 11.9C29.3 12.4 29.3 13.2 30.2 13.8L39.1 18.8C40 19.4 40.7 20.6 40.7 21.7L40.7 39C40.7 40.1 41.4 40.5 42.4 40L48.2 36.6C49.1 36.1 49.8 34.9 49.8 33.8L49.8 15.6C49.8 14.6 49.1 13.3 48.2 12.8L40 8.2 40 8.2ZM27 10.1L33.6 6.4C34.5 5.9 34.5 5 33.6 4.5L26.6 0.5C25.6 0 24.2 0 23.3 0.5L16.7 4.2C15.8 4.7 15.8 5.6 16.7 6.1L23.7 10.1C24.7 10.6 26.1 10.6 27 10.1ZM10.1 21.7C10.1 20.6 10.8 19.4 11.7 18.8L20.6 13.8C21.5 13.2 21.5 12.4 20.6 11.9L13.6 7.9C12.7 7.4 11.2 7.4 10.3 7.9L1.6 12.8C0.7 13.3 0 14.6 0 15.6L0 33.8C0 34.9 0.7 36.1 1.6 36.6L8.4 40.5C9.3 41 10.1 40.6 10.1 39.6L10.1 21.7 10.1 21.7Z"></path></g></svg><span>Offers &amp; Deals</span></a><ul class="flyout"><li><a href="https://get.oreilly.com/email-signup.html" target="_blank" class="l2 nav-icn"><span>Newsletters</span></a></li></ul></li><li class="nav-highlights"><a href="https://learning.oreilly.com/u/b28f9685-65fa-4f95-827a-bc87c37860af/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" width="20" height="20" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z"></path></g></svg><span>Highlights</span></a></li><li><a href="https://learning.oreilly.com/u/preferences/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l1 no-icon">Support</a></li><li><a href="https://learning.oreilly.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://learning.oreilly.com/u/preferences/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a><span class="l2 t-nag-notification" id="nav-nag"><strong class="trial-green">10</strong> days left in your trial.
  
  

  
    
      

<a class="" href="https://learning.oreilly.com/subscribe/">Subscribe</a>.


    
  

  

</span></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l2">Support</a></li><li><a href="https://learning.oreilly.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application" style="height: auto;">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Fundamentals of Computer Graphics, 4th Edition
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9781482229417/chapter/K22616_C003.xhtml"><div class="js-collections-dropdown collections-dropdown menu-bit-cards"><div data-reactroot="" class="menu-dropdown-wrapper js-menu-dropdown-wrapper align-right"><img class="hidden" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/ajax-transp.gif" alt="loading spinner"><div class="menu-control"><div class="control "><div class="js-playlists-menu"><button class="js-playlist-icon"><svg class="icon-add-to-playlist-sml" viewBox="0 0 16 14" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill-rule="nonzero" fill="#000000"><g transform="translate(-1.000000, 0.000000)"><rect x="5" y="0" width="12" height="2"></rect><title>Playlists</title><path d="M4.5,14 C6.43299662,14 8,12.4329966 8,10.5 C8,8.56700338 6.43299662,7 4.5,7 C2.56700338,7 1,8.56700338 1,10.5 C1,12.4329966 2.56700338,14 4.5,14 Z M2.5,10 L4,10 L4,8.5 L5,8.5 L5,10 L6.5,10 L6.5,11 L5,11 L5,12.5 L4,12.5 L4,11 L2.5,11 L2.5,10 Z"></path><circle cx="2" cy="5" r="1"></circle><circle cx="1.94117647" cy="1" r="1"></circle><rect x="5" y="4" width="12" height="2"></rect><rect x="9" y="8" width="8" height="2"></rect><rect x="9" y="12" width="8" height="2"></rect></g></g></g></svg><div class="js-playlist-addto-label">Add&nbsp;To</div></button></div></div></div></div></div></div></li><li class="js-font-control-panel font-control-activator"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml&amp;text=Fundamentals%20of%20Computer%20Graphics%2C%204th%20Edition&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%20Chapter%203%20Raster%20Images&amp;body=https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C003.xhtml%0D%0Afrom%20Fundamentals%20of%20Computer%20Graphics%2C%204th%20Edition%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C016.xhtml" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 16 Computer Animation</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C018.xhtml" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 18 Light</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><p class="h1Number">Chapter 17</p>
<h1><a id="page_436"></a><a id="page_437"></a>Using Graphics Hardware</h1>
<p class="h1Author">Peter Willemsen</p>
<h2><a id="sec17-1"></a>17.1 Hardware Overview</h2>
<p>Throughout most of this book, the focus is on the fundamentals that underly computer graphics rather than on any specifics relating to the APIs or hardware on which the algorithms may be implemented. This chapter takes a slightly different route and blends the details of using graphics hardware with some of the practical issues associated with programming that hardware. The chapter is designed to be an introductory guide to graphics hardware and could be used as the basis for a set of weekly labs that investigate graphics hardware.</p>
<h2><a id="sec17-2"></a>17.2 What Is Graphics Hardware</h2>
<p><span class="cItalic">Graphics hardware</span> describes the hardware components necessary to quickly render 3D objects as pixels on your computer’s screen using specialized rasterization-based (and in some cases, ray-tracer–based) hardware architectures. The use of the term <span class="cItalic">graphics hardware</span> is meant to elicit a sense of the physical components necessary for performing a range of graphics computations. In other words, the hardware is the set of chipsets, transistors, buses, processors, and computing cores found on current video cards. As you will learn in this chapter, and eventually experience yourself, current graphics hardware is very good at processing<a id="page_438"></a> descriptions of 3D objects and transforming those representations into the colored pixels that fill your monitor.</p>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Real-Time Graphics:</span> By real-time graphics, we generally mean that the graphics-related computations are being carried out fast enough that the results can be viewed immediately. Being able to conduct operations at 60Hz or higher is considered real time. Once the time to refresh the display (<span class="cItalic">frame rate</span>) drops below 15Hz, the speed is considered more interactive than it is real-time, but this distinction is not critical. Because the computations need to be fast, the equations used to render the graphics are often approximations to what could be done if more time were available.</p>
</div>
<p>Graphics hardware has certainly changed very <span class="cItalic">rapidly</span> over the last decade. Newer graphics hardware provides more parallel processing capabilities, as well as better support for specialized rendering. One explanation for the fast pace is the video game industry and its economic momentum. Essentially what this means is that each new graphics card provides better performance and processing capabilities. As a result, video games appear more visually realistic. The processors on graphics hardware, often called GPUs, or Graphics Processing Units, are highly parallel and afford thousands of concurrent threads of execution. The hardware is designed for throughput which allows larger numbers of pixels and vertices to be processed in shorter amounts of time. All of this parallelism is good for graphics algorithms, but other work has benefited from the parallel hardware. In addition to video games, GPUs are used to accelerate physics computations, develop real-time ray tracing codes, solve Navier-Stokes related equations for fluid flow simulations, and develop faster codes for understanding the climate (Purcell, Buck, Mark, &amp; Hanrahan, 2002; S. G. Parker et al., 2010; Harris, 2004). Several APIs and SDKs have been developed that afford more direct general purpose computation, such as OpenCL and NVIDIA’s CUDA. Hardware accelerated ray tracing APIs also exist to accelerate ray-object intersection (S. G. Parker et al., 2010). Similarly, the standard APIs that are used to program the graphics components of video games, such as OpenGL and DirectX, also allow mechanisms to leverage the graphics hardware’s parallel capabilities. Many of these APIs change as new hardware is developed to support more sophisticated computations.</p>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Fragment:</span> <span class="cItalic">Fragment</span> is a term that describes the information associated with a pixel prior to being processed in the final stages of the graphics pipeline. This definition includes much of the data that might be used to calculate the color of the pixel, such as the pixel’s scene depth, texture coordinates, or stencil information.</p>
</div>
<p>Graphics hardware is programmable. As a developer, you have control over much of the computations associated with processing geometry, vertices, and the fragments that eventually become pixels. Recent hardware changes as well as ongoing updates to the APIs, such as OpenGL or DirectX, support a completely programmable pipeline. These changes afford developers creative license to exploit the computation available on GPUs. Prior to this, fixed-function rasterization pipelines forced the computation to a specific style of vertex transformations, lighting, and fragment processing. The fixed functionality of the pipeline ensured that basic coloring, lighting, and texturing could occur very quickly. Whether it is a programmable interface, or fixed-function computation, the basic computations of the rasterization pipeline are similar, and follow the illustration in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-1">Figure 17.1</a>. In the rasterization pipeline, vertices are transformed from local space to global space, and eventually into screen coordinates, after being transformed by the viewing and projection transformation matrices. The set of screen coordinates associated with a geometry’s vertices are rasterized into fragments. The final stages of the pipeline process the fragments into pixels and can apply<a id="page_439"></a> per-fragment texture lookups, lighting, and any necessary blending. In general, the pipeline lends itself to parallel execution and the GPU cores can be used to process both vertices and fragments concurrently. Additional details about the rasterization pipeline can be found in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C008.xhtml">Chapter 8</a>.</p>
<div id="art_Dest_fig_17-1" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-1"></a><span class="cBold">Figure 17.1</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-1.png" alt="Figure showing the basic graphics hardware pipeline consists of stages that transform 3D data into 2D screen objects ready for rasterizing and coloring by the pixel processing stages." width="403" height="697" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-1.png"></p>
<p class="Text figcaption">The basic graphics hardware pipeline consists of stages that transform 3D data into 2D screen objects ready for rasterizing and coloring by the pixel processing stages.</p>
</div>
<h2><a id="sec17-3"></a>17.3 Heterogeneous Multiprocessing</h2>
<p>When using graphics hardware, it is convenient to distinquish between the CPU and the GPU as separate computational entities. In this context, the term <span class="cItalic">host</span> is used to refer to the CPU including the threads and memory available to it. The term <span class="cItalic">device</span> is used to refer to the GPU, or the graphics processing units, and the threads and memory associated with it. This makes some sense because most graphics hardware is comprised of external hardware that is connected to the machine via the PCI bus. The hardware may also be soldered to the machine as a separate chipset. In this sense, the graphics hardware represents a specialized co-processor since both the CPU (and its cores) can be programmed, as can the GPU and its cores. All programs that utilize graphics hardware must first establish a mapping between the CPU and the GPU memory. This is a rather low-level detail that is necessary so that the graphics hardware driver residing within the operating system can interface between the hardware and the operating system and windowing system software. Recall that because the host (CPU) and the device (GPU)<a id="page_440"></a> are separate, data must be communicated between the two systems. More formally, this mapping between the operating system, the hardware driver, the hardware, and the windowing system is known as the graphics <span class="cItalic">context</span>. The context is usually established through API calls to the windowing system. Details about establishing a context is outside the scope of this chapter, but many windowing system development libraries have ways to query the graphics hardware for various capabilities and establish the graphics context based on those requirements. Because setting up the context is windowing system dependent, it also means that such code is not likely to be cross-platform code. However, in practice, or at least when starting out, it is very unlikely that such low-level context setup code will be required since many higher level APIs exist to help people develop portable interactive applications.</p>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Host:</span> In a graphics hardware program, the host refers to the CPU components of the application.</p>
</div>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Device:</span> The GPU side of the graphics application, including the data and computation that are stored and executed on the GPU.</p>
</div>
<p>Many of the frameworks for developing interactive applications support querying input devices such as the keyboard or mouse. Some frameworks provide access to the network, audio system, and other higher level system resources. In this regard, many of these APIs are the preferred way to develop graphics, and even game applications.</p>
<p>Cross-platform hardware acceleration is often achieved with the OpenGL API. OpenGL is an open industry standard graphics API that supports hardware acceleration on many types of graphics hardware. OpenGL represents one of the most common APIs for programming graphics hardware along with APIs such as DirectX. While OpenGL is available on many operating systems and hardware architectures, DirectX is specific to Microsoft-based systems. For the purposes of this chapter, hardware programming concepts and examples will be presented with OpenGL.</p>
<h3><a id="sec17-3-1"></a>17.3.1 Programming with OpenGL</h3>
<p>When you program with the OpenGL API, you are writing code for at least two processors: the CPU(s) and the GPU(s). OpenGL is implemented in a C-style API and all functions are prefixed with “gl” to indicate their inclusion with OpenGL. OpenGL function calls change the state of the graphics hardware and can be used to declare and define geometry, load vertex and fragment shaders, and determine how computation will occur as data passes through the hardware.</p>
<p>The variant of OpenGL that this chapter presents is the OpenGL 3.3 Core Profile version. While not the most recent version of OpenGL, the 3.3 version of OpenGL is in line with the future direction of OpenGL programming. These versions are focused on improving efficiency while also fully placing the programming of the pipeline within the hands of the developer. Many of the function<a id="page_441"></a> calls present in earlier versions of OpenGL are not present in these newer APIs. For instance, <span class="cItalic">immediate mode</span> rendering is deprecated. Immediate mode rendering was used to send data from the CPU memory to the graphics card memory as needed each frame and was often very inefficient, especially for larger models and complex scenes. The current API focuses on storing data on the graphics card before it is needed and instancing it at render time. As another example, OpenGL’s matrix stacks have been deprecated as well, leaving the developer to use third-party matrix libraries (such as GLM) or their own classes to create the necessary matrices for viewing, projection, and transformation, as presented in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C007.xhtml">Chapter 7</a>. As a result, OpenGL’s shader language (GLSL) has taken on larger roles as well, performing the necessary matrix tranformations along with lighting and shading within the shaders. Because the fixed-function pipeline which performed per-vertex transformation and lighting is no longer present, programmers must develop all shaders themselves. The shading examples presented in this chapter will utilize the GLSL 3.3 Core Profile version shader specification. Future readers of this chapter will want to explore the current OpenGL and OpenGL Shading Language specifications for additional details on what these APIs and languages can support.</p>
<h2><a id="sec17-4"></a>17.4 Graphics Hardware Programming: Buffers, State, and Shaders</h2>
<p>Three concepts will help to understand contemporary graphics hardware programming. The first is the notion of a data <span class="cItalic">buffer</span>, which is quite simply, a linear allocation of memory on the device that can store various data on which the GPUs will operate. The second is the idea that the graphics card maintains a computational <span class="cItalic">state</span> that determines how computations associated with scene data and shaders will occur on the graphics hardware. Moreover, state can be communicated from the host to the device and even within the device between shaders. <span class="cItalic">Shaders</span> represent the mechanism by which computation occurs on the GPU related to per-vertex or per-fragment processing. This chapter will focus on vertex and fragment shaders, but specialized geometry and compute shaders also exist in the current versions of OpenGL. Shaders play a very important role in how modern graphics hardware functions.</p>
<h3><a id="sec17-4-1"></a>17.4.1 Buffers</h3>
<p>Buffers are the primary structure to store data on graphics hardware. They represent the graphics hardware’s internal memory associated with everything from<a id="page_442"></a> geometry, textures, and image plane data. With regard to the rasterization pipeline described in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C008.xhtml">Chapter 8</a>, the computations associated with hardware-accelerated rasterization read and write the various buffers on the GPU. From a programming standpoint, an application must initialize the buffers on the GPU that are needed for the application. This amounts to a host to device copy operation. At the end of various stages of execution, device to host copies can be performed as well to pull data from the GPU to the CPU memory. Additionally, mechanisms do exist in OpenGL’s API that allow device memory to be mapped into host memory so that an application program can write directly to the buffers on the graphics card.</p>
<h3><a id="sec17-4-2"></a>17.4.2 Display Buffer</h3>
<p>In the graphics pipeline, the final set of pixel colors can be linked to the display, or they may be written to disk as a PNG image. The data associated with these pixels is generally a 2D array of color values. The data is inherently 2D, but it is efficiently represented on the GPU as a 1D linear array of memory. This array implements the <span class="cItalic">display buffer</span>, which eventually gets mapped to the window. Rendering images involves communicating the changes to the display buffer on the graphics hardware through the graphics API. At the end of the rasterization pipeline, the fragment processing and blending stages write data to the output display buffer memory. Meanwhile, the windowing system reads the contents of the display buffer to produce the raster images on the monitor’s window.</p>
<h3><a id="sec17-4-3"></a>17.4.3 Cycle of Refresh</h3>
<p>Most applications prefer a double-buffered display state. What this means is that there are two buffers associated with a graphics window: the front buffer and the back buffer. The purpose of the double-buffered system is that the application can communicate changes to the back buffer (and thus, write changes to that buffer) while the front-buffer memory is used to drive the pixel colors on the window.</p>
<p>At the end of the rendering loop, the buffers are swapped through a pointer exchange. The front-buffer pointer points to the back buffer and the back-buffer pointer is then assigned to the previous front buffer. In this way, the windowing system will refresh the content of the window with the most up-to-date buffer. If the buffer pointer swap is synchronized with the windowing system’s refresh of the entire display, the rendering will appear seamless. Otherwise, users may observe a tearing of the geometry on the actual display as changes to the scene’s geometry and fragments are processed (and thus written to the display buffer) faster than the screen is refreshed.</p>
<p><a id="page_443"></a>When the display is considered a memory buffer, one of the simplest operations on the display is essentially a memory setting (or copying) operation that zeros-out, or clears the memory to a default state. For a graphics program, this likely means clearing the background of the window to a specific color. To clear the background color (to black) in an OpenGL application, the following code can be used:</p>
<pre><span class="code">glClearColor(0.0f, 0.0f, 0.0f, 1.0f);</span></pre>
<pre><span class="code">glClear(GL_COLOR_BUFFER_BIT);</span></pre>
<p>The first three arguments for the <span class="code">glClearColor</span> function represent the <span class="cItalic">red, green,</span> and <span class="cItalic">blue</span> color components, specified within the range [0, 1]. The fourth argument represents opacity, or <span class="cItalic">alpha</span> value, ranging from 0.0 being completely transparent to 1.0 being completely opaque. The <span class="cItalic">alpha</span> value is used to determine transparency through various fragment blending operations in the final stages of the pipeline.</p>
<p>This operation only clears the color buffer. In addition to the color buffer, specified by <span class="code">GL_COLOR_BUFFER_BIT</span>, being cleared to black in this case, graphics hardware also uses a depth buffer to represent the distance that fragments are relative to the camera (you may recall the discussion of the z-buffer algorithm in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C008.xhtml">Chapter 8</a>). Clearing the depth buffer is necessary to ensure operation of the z-buffer algorithm and allow correct hidden surface removal to occur. Clearing the depth buffer can be achieved by <span class="cItalic">or</span>’ing two bit field values together, as follows:</p>
<pre><span class="code">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span></pre>
<p>Within a basic interactive graphics application, this step of clearing is normally the first operation performed before any geometry or fragments are processed.</p>
<h2><a id="sec17-5"></a>17.5 State Machine</h2>
<p>By illustrating the buffer-clearing operation for the display’s color and depth buffers, the idea of graphics hardware <span class="cItalic">state</span> is also introduced. The <span class="code">glClearColor</span> function sets the default color values that are written to all the pixels within the color buffer when <span class="code">glClear</span> is called. The clear call initializes the color component of the display buffer and can also reset the values of the depth buffer. If the clear color does not change within an application, the clear color need only be set once, and often this is done in the initialization of an OpenGL program. Each time that <span class="code">glClear</span> is called it uses the previously set state of the clear color.</p>
<p><a id="page_444"></a>Note also that the z-buffer algorithm state can be enabled and disabled as needed. The z-buffer algorithm is also known in OpenGL as the depth test. By enabling it, a fragment’s depth value will be compared to the depth value currently stored in the depth buffer prior to writing any fragment colors to the color buffer. Sometimes, the depth test is not necessary and could potentially slow down an application. Disabling the depth test will prevent the z-buffer computation and change the behavior of the executable. Enabling the z-buffer test with OpenGL is done as follows:</p>
<pre><span class="code">glEnable(GL_DEPTH_TEST);</span></pre>
<pre><span class="code">glDepthFunc(GL_LESS);</span></pre>
<p>The <span class="code">glEnable</span> call turns on the depth test while the <span class="code">glDepthFunc</span> call sets the mechanism for how the depth comparison is performed. In this case, the depth function is set to its default value of <span class="code">GL_LESS</span> to show that other state variables exist and can be modified. The converse of the <span class="code">glEnable</span> calls are <span class="code">glDisable</span> calls.</p>
<p>The idea of state in OpenGL mimics the use of static variables in object-oriented classes. As needed, programmers enable, disable, and/or set the state of OpenGL variables that reside on the graphics card. These state then affect any succeeding computations on the hardware. In general, efficient OpenGL programs attempt to minimize state changes, enabling states that are needed, while disabling states that are not required for rendering.</p>
<h2><a id="sec17-6"></a>17.6 Basic OpenGL Application Layout</h2>
<p>A simple and basic OpenGL application has, at its heart, a display loop that is called either as fast as possible, or at a rate that coincides with the refresh rate of the monitor or display device. The example loop below uses the GLFW library, which supports OpenGL coding across multiple platforms.</p>
<div class="Box">
<pre><span class="code">while (!glfwWindowShouldClose(window)) {</span></pre>
<pre><span class="code"> {</span></pre>
<pre><span class="code"> // OpenGL code is called here,</span></pre>
<pre><span class="code"> // each time this loop is executed.</span></pre>
<pre><span class="code"> glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span></pre>
<pre></pre>
<pre><span class="code"> // Swap front and back buffers</span></pre>
<pre><span class="code">	  glfwSwapBuffers(window);</span></pre>
<pre></pre>
<pre><span class="code"> // Poll for events</span></pre>
<pre><span class="code">	  glfwPollEvents() ;</span></pre>
<pre><span class="code">  <a id="page_445"></a> if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span></pre>
<pre><span class="code">  glfwSetWindowShouldClose(window, 1);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>The loop is tightly constrained to operate only while the window is open. This example loop resets the color buffer values and also resets the z-buffer depth values in the graphics hardware memory based on previously set (or default) values. Input devices, such as keyboards, mouse, network, or some other interaction mechanism are processed at the end of the loop to change the state of data structures associated with the program. The call to glfwSwapBuffers synchronizes the graphics context with the display refresh, performing the pointer swap between the front and back buffers so that the updated graphics state is displayed on the user’s screen. The call to swap the buffers occurs after all graphics calls have been issued.</p>
<p>While conceptually separate, the depth and color buffers are often collectively called the <span class="cItalic">framebuffer</span>. By clearing the contents of the framebuffer, the application can proceed with additional OpenGL calls to push geometry and fragments through the graphics pipeline. The framebuffer is directly related to the size of the window that has been opened to contain the graphics context. The window, or viewport, dimensions are needed by OpenGL to construct the <span class="cItalic">M<span class="cSubscript">vp</span></span> matrix (from <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C007.xhtml">Chapter 7</a>) within the hardware. This is accomplished through the following code, demonstrated again with the GLFW toolkit, which provides functions for querying the requested window (or framebuffer) dimensions:</p>
<pre><span class="code">int nx, ny;</span></pre>
<pre><span class="code">glfwGetFramebufferSize(window, &amp;nx, &amp;ny);</span></pre>
<pre><span class="code">glViewport(0, 0, nx, ny);</span></pre>
<p>In this example, <span class="code">glViewport</span> sets the OpenGL state for the window dimension using nx and ny for the width and height of the window and the viewport being specified to start at the origin.</p>
<p>Technically, OpenGL writes to the framebuffer memory as a result of operations that rasterize geometry, and process fragments. These writes happen before the pixels are displayed on the user’s monitor.</p>
<h2><a id="sec17-7"></a>17.7 Geometry</h2>
<p>Similar to the idea of a display buffer, geometry is also specified using arrays to store vertex data and other vertex attributes, such as vertex colors, normals, or texture coordinates needed for shading. The concept of buffers will be used to<a id="page_446"></a> allocate storage on the graphics hardware, transferring data from the host to the device.</p>
<h3><a id="sec17-7-1"></a>17.7.1 Describing Geometry for the Hardware</h3>
<p>One of the challenges with graphics hardware programming is the management of the 3D data and its transfer to and from the memory of the graphics hardware. Most graphics hardware work with specific sets of geometric primitives. The different primitive types leverage primitive complexity for processing speed on the graphics hardware. Simpler primitives can sometimes be processed very fast. The caveat is that the primitive types need to be general purpose so as to model a wide range of geometry from very simple to very complex. On typical graphics hardware, the primitive types are limited to one or more of the following:</p>
<ul>
<li class="LX"><span class="cBold">points</span>—single vertices used to represent points or particle systems;</li>
<li class="LX"><span class="cBold">lines</span>—pairs of vertices used to represent lines, silhouettes, or edge-highlighting;</li>
<li class="LX"><span class="cBold">triangles</span>—triangles, triangle strips, indexed triangles, indexed triangle strips, quadrilaterals, or triangle meshes approximating geometric surfaces.</li>
</ul>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Primitives:</span> The three primitives (points, lines, triangles, and quads) are really the only primitives available! Even  when creating spline-based surfaces, such as NURBS, the surfaces are tessellated into triangle primitives by the graphics hardware.</p>
</div>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">Point Rendering</span>: Point and line primitives may initially appear to be limited in use, but researchers have used points to render very complex geometry (Rusinkiewicz &amp; Levoy, 2000; Dachsbacher, Vogelgsang, &amp; Stamminger, 2003).</p>
</div>
<p>These three primitive types form the basic building blocks for most geometry that can be defined. An example of a triangle mesh rendered with OpenGL is shown in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-2">Figure 17.2</a>.</p>
<div id="art_Dest_fig_17-2" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-2"></a><span class="cBold">Figure 17.2</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-2.png" alt="Figure showing how your geometry is organized will affect the performance of your application. This wireframe depiction of the Little Cottonwood Canyon terrain dataset shows tens of thousands of triangles organized as a triangle mesh running at real-time rates." width="600" height="228" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-2.png"></p>
<p class="Text figcaption">How your geometry is organized will affect the performance of your application. This wireframe depiction of the Little Cottonwood Canyon terrain dataset shows tens of thousands of triangles organized as a triangle mesh running at real-time rates.</p>
<p class="Text figsource"><span class="cItalic">The image is rendered using the VTerrain Project terrain system courtesy of Ben Discoe.</span></p>
</div>
<h2><a id="page_447"></a><a id="sec17-8"></a>17.8 A First Look at Shaders</h2>
<p>Modern versions of OpenGL require that shaders be used to process vertices and fragments. As such, no primitives can be rendered without at least one vertex shader to process the incoming primitive vertices and another shader to process the rasterized fragments. Advanced shader types exist within OpenGL and the OpenGL Shading Language: <span class="cItalic">geometry shaders</span> and <span class="cItalic">compute shaders</span>. Geometry shaders are designed to process primitives, potentially creating additional primitives, and can support geometric instancing operations. Compute shaders are designed for performing general computation on the GPU, and can be linked into the set of shaders necessary for a specific application. For more information on geometry and compute shaders, the reader is referred the OpenGL specification documents and other resources.</p>
<h3><a id="sec17-8-1"></a>17.8.1 Vertex Shader Example</h3>
<p>Vertex shaders provide control over how vertices are transformed and often help prepare data for use in fragment shaders. In addition to standard transformations and potential per-vertex lighting operations, vertex shaders could be used to perform general computation on the GPU. For instance, if the vertices represent particles and the particle motion can be (simply) modeled within the vertex shader computations, the CPU can mostly be removed from performing those computations. The ability to perform computations on the vertices already stored in the graphics hardware memory is a potential performance gain. While this approach is useful in some situations, advanced general computation may be more appropriately coded with compute shaders.</p>
<p>In <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C007.xhtml">Chapter 7</a>, the viewport matrix <span class="cItalic">M<span class="cSubscript">vp</span></span> was introduced. It transforms the canonical view volume coordinates to screen coordinates. Within the canonical view volume, coordinates exist in the range of [−1, 1]. Anything outside of this range is clipped. If we make an initial assumption that the geometry exists within this range and the z-value is ignored, we can create a very simple vertex shader. This vertex shader passes the vertex positions through to the rasterization stage, where the final viewport transformation will occur. Note that because of this simplification, there are no projection, viewing, or model transforms that will be applied to the incoming vertices. This is initially cumbersome for creating anything except very simple scenes, but will help introduce the concepts of shaders and allow you to render an initial triangle to the screen. The <span class="cItalic">passthrough</span> vertex shader follows:</p>
<div class="Box">
<pre><span class="code"><a id="page_448"></a>#version 330 core</span></pre>
<pre><span class="code">layout (location=0) in vec3 in_Position;</span></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> gl_Position = vec4(in_Position, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>This vertex shader does only one thing. It passes the incoming vertex position out as the <span class="code">gl_Position</span> that OpenGL uses to rasterize fragments. Note that <span class="code">gl_Position</span> is a built-in, reserved variable that signifies one of the key outputs required from a vertex shader. Also note the version string in the first line. In this case, the string instructs the GLSL compiler that version 3.3 of the GLSL Core profile is to be used to compile the shading language.</p>
<p>Vertex and fragment shaders are SIMD operations that respectively operate on all the vertices or fragments being processed in the pipeline. Additional data can be communicated from the host to the shaders executing on the device by using input, output, or uniform variables. Data that is passed into a shader is prefixed with the keyword in. The location of that data as it relates to specific vertex attributes or fragment output indices is also specified directly in the shader. Thus,</p>
<pre><span class="code">layout(location=0) in vec3 in_Position;</span></pre>
<p>specifies that <span class="code">in_Position</span> is an input variable that is of type <span class="code">vec3</span>. The source of that data is the attribute index <span class="cBold">0</span> that is associated with the geometry. The name of this variable is determined by the programmer, and the link between the incoming geometry and the shader occurs while setting up the vertex data on the device. The GLSL contains a nice variety of types useful to graphics programs, including <span class="code">vec2, vec3, vec4, mat2, mat3</span>, and <span class="code">mat4</span> to name a few. Standard types such as <span class="code">int</span> or <span class="code">float</span> also exist. In shader programming, vectors, such as <span class="code">vec4</span> hold 4-components corresponding to the <span class="cItalic">x, y, z,</span> and <span class="cItalic">w</span> components of a homogeneous coordinate, or the <span class="cItalic">r, g, b,</span> and <span class="cItalic">a</span> components of a RGBA tuple. The labels for the types can be interchanged as needed (and even repeated) in what is called <span class="cItalic">swizzling</span> (e.g., in_Position.zyxa). Moreover, the component-wise labels are overloaded and can be used appropriately to provide context.</p>
<p>All shaders must have a main function that performs the primary computation across all inputs. In this example, the main function simply copies the input vertex position (<span class="code">in_Position</span>), which is of type <span class="code">vec3</span> into the built-in vertex shader output variable, which is of type <span class="code">vec4</span>. Note that many of the built-in types have constructors that are useful for conversions such as the one presented here to convert the incoming vertex position’s <span class="code">vec3</span> type into <span class="code">gl_Position</span>’s <span class="code">vec4</span><a id="page_449"></a> type. Homogeneous coordinates are used with OpenGL, so 1.0 is specified as the fourth coordinate to indicate that the vector is a position.</p>
<h3><a id="sec17-8-2"></a>17.8.2 Fragment Shader Example</h3>
<p>If the simplest vertex shader simply passes clip coordinates through, the simplest fragment shader sets the color of the fragment to a constant value.</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre></pre>  
<pre><span class="code">layout(location=0) out vec4 out_FragmentColor;</span></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> out_FragmentColor = vec4(0.49, 0.87, 0.59, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>In this example, all fragments will be set to a light shade of green. One key difference is the use of the <span class="code">out</span> keyword. In general, the keywords <span class="code">in</span> and <span class="code">out</span> in shader programs indicate the flow of data into, and out of, shaders. While the vertex shader received incoming vertices and output them to a built-in variable, the fragment shader declares its outgoing value which is written out to the color buffer:</p>
<pre><span class="code">layout(location=0) out vec4 out_FragmentColor;</span></pre>
<p>The output variable <span class="code">out_FragmentColor</span> is again user defined. The location of the output is color buffer index <span class="cBold">0</span>. Fragment shaders can output to multiple buffers, but this is an advanced topic left to the reader that will be needed if OpenGL’s framebuffer objects are investigated. The use of the <span class="code">layout</span> and <span class="code">location</span> keywords makes an explicit connection between the application’s geometric data in the vertex shader and the output color buffers in the fragment shader.</p>
<h3><a id="sec17-8-3"></a>17.8.3 Loading, Compiling, and Using Shaders</h3>
<p>Shader programs are transferred onto the graphics hardware in the form of character strings. They must then be compiled and linked. Furthermore, shaders are coupled together into shader programs so that vertex and fragment processing occur in a consistent manner. A developer can activate a shader that has been successfully compiled and linked into a shader program as needed, while also deactivating shaders when not required. While the detailed process of creating,<a id="page_450"></a> loading, compiling, and linking shader programs is not provided in this chapter, the following OpenGL functions will be helpful in creating shaders:</p>
<ul>
<li class="LX"><span class="cBold">glCreateShader</span> creates a handle to a shader on the hardware.</li>
<li class="LX"><span class="cBold">glShaderSource</span> loads the character strings into the graphics hardware memory.</li>
<li class="LX"><span class="cBold">glCompileShader</span> performs the actual compilation of the shader within the hardware.</li>
</ul>
<p>The functions above need to be called for each shader. So, for the simple pass-through shaders, each of those functions would be called for both the vertex shader code and the fragment shader code provided. At the end of the compilation phase, compilation status and any errors can be queried using additional OpenGL commands.</p>
<p>After both shader codes are loaded and compiled, they can be linked into a shader program. The shader program is what is used to affect rendering of geometry.</p>
<ul>
<li class="LX"><span class="cBold">glCreateProgram</span> creates a program object that will contain the previously compiled shaders.</li>
<li class="LX"><span class="cBold">glAttachShader</span> attaches a shader to the shader program object. In the simple example, this function will be called for both the compiled vertex shader and the compiled fragment shader objects.</li>
<li class="LX"><span class="cBold">glLinkProgram</span> links the shaders internally after all shaders have been attached to the program object.</li>
<li class="LX"><span class="cBold">glUseProgram</span> binds the shader program for use on the graphics hardware. As shaders are needed, the program handles are bound using this function. When no shaders are needed, they can be unbound by using the shader program handle <span class="cBold">0</span> as an argument to this function.</li>
</ul>
<h2><a id="sec17-9"></a>17.9 Vertex Buffer Objects</h2>
<p>Vertices are stored on the graphics hardware using buffers, known as <span class="cItalic">vertex buffer objects.</span> In addition to vertices, any additional <span class="cItalic">vertex attributes,</span> such as colors, normal vectors, or texture coordinates, will also be specified using vertex buffer objects.</p>
<p><a id="page_451"></a>First, let’s focus on specifying the geometric primitive themselves. This starts by allocating the vertices associated with the primitive within the host memory of the application. The most general way to do this is to define an array on the host to contain the vertices needed for the primitive. For instance, a single triangle, fully contained within the canonical volume, could be defined statically on the host as follows:</p>
<pre><span class="code">GLfloat vertices[] = {-0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f};</span></pre>
<p>If the simple passthrough shaders are used for this triangle, then all vertices will be rendered. Although the triangle is placed on the <span class="cItalic">z</span> = 0 plane, the <span class="cItalic">z</span> coordinates for this example do not really matter since they are essentially dropped in the final transformation into screen coordinates. Another thing to note is the use of the type <span class="code">GLfloat</span> in these examples. Just as the GLSL language has specialized types, OpenGL has related type which generally can intermix well with the standard types (like float). For preciseness, the OpenGL types will be used when necessary.</p>
<div class="Sidebar">
<p class="SidebarText"><span class="cBold">OpenGL Coordinate System:</span> The coordinate system used by OpenGL is identical to that presented in this book. It is a right-handed coordinate system with +<span class="cItalic">x</span> to the right, +<span class="cItalic">y</span> up, and +<span class="cItalic">z</span> away from the screen (or window). Thus, −<span class="cItalic">z</span> points into the monitor.</p>
</div>
<p>Before the vertices can be processed, a vertex buffer is first created on the device to store the vertices. The vertices on the host are then transferred to the device. After this, the vertex buffer can be referenced as needed to draw the array of vertices stored in the buffer. Moreover, after the initial transfer of vertex data, no additional copying of data across the host to device bus need occur, especially if the geometry remains static across rendering loop updates. Any host memory can also be deleted if it was dynamically allocated.</p>
<p>Vertex buffer objects, often called VBOs, represent the primary mechanism with modern OpenGL to store vertex and vertex attributes in the graphics memory. For efficiency purposes, the initial setup of a VBO and the transfer of vertex-related data mostly happens prior to entering the display loop. As an example, to create a VBO for this triangle, the following code could be used:</p>
<pre><span class="code">GLuint triangleVBO[1];</span></pre>
<pre><span class="code">glGenBuffers(1, triangleVBO);</span></pre>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0]);</span></pre>
<pre><span class="code">glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span></pre>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, 0);</span></pre>
<p>Three OpenGL calls are required to create and allocate the vertex buffer object. The first, <span class="code">glGenBuffers</span> creates a handle that can be used to refer to the VBO once it is stored on the device. Multiple handles to VBOs (stored in arrays) can be created in a single <span class="code">glGenBuffers</span> call, as illustrated but not utilized here. Note that when a buffer object is generated, the actual allocation of space on the device is not yet performed.</p>
<p>With OpenGL, <span class="cItalic">objects</span>, such as vertex buffer objects, are primary targets for computation and processing. Objects must be bound to a known OpenGL state<a id="page_452"></a> when used and unbound when not in use. Examples of OpenGL’s use of objects include the vertex buffer objects, framebuffer objects, texture objects, and shader programs, to name a few. In the current example, the <span class="code">GL_ARRAY_BUFFER</span> state of OpenGL is bound to the triangle VBO handle that was generated previously. This essentially makes the triangle VBO the active vertex buffer object. Any operations that affect vertex buffers that follow the <span class="code">glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0])</span> command will use the triangle data in the VBO either by reading the data or writing to it.</p>
<p>Vertex data is copied from the host (the <span class="code">vertices array</span>) to the device (currently bound <span class="code">GL_ARRAY_BUFFER</span>) using the</p>
<pre><span class="code">glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span></pre>
<p>call. The arguments represent the type of target, the size in bytes of the buffer to be copied, the pointer to the host buffer, and an enumerated type that indicates how the buffer will be used. In the current example, the target is <span class="code">GL_ARRAY_BUFFER</span>, the size of the data is 9* <span class="code">sizeof(GLfloat)</span>, and the last argument is <span class="code">GL_STATIC_DRAW</span> indicating to OpenGL that the vertices will not change over the course of the rendering. Finally, when the VBO no longer needs to be an active target for reading or writing, it is unbound with the <span class="code">glBindBuffer(GL_ARRAY _BUFFER, 0)</span> call. In general, binding any of OpenGL’s objects or buffers to handle 0, unbinds, or disables that buffer from affecting subsequent functionality.</p>
<h2><a id="sec17-10"></a>17.10 Vertex Array Objects</h2>
<p>While vertex buffer objects are the storage containers for vertices (and vertex attributes), <span class="cItalic">vertex array objects</span> represent OpenGL’s mechanism to bundle vertex buffers together into a consistent vertex state that can be communicated and linked with shaders in the graphics hardware. Recall that the fixed function pipeline of the past no longer exists and therefore, per-vertex state, such as normals or even vertex colors, must be stored in hardware buffers and then referenced in shaders, using input variables (e.g., in).</p>
<p>As with vertex buffer objects, vertex array objects, or VAOs, must be created and allocated with any necessary state being set while the vertex array object is bound. For instance, the following code shows how to create a VAO to contain the triangle VBO previously defined:</p>
<pre><span class="code">GLuint VAO;</span></pre>
<pre><span class="code">glGenVertexArrays(1, &amp;VAO);</span></pre>
<pre><span class="code">glBindVertexArray(VAO);</span></pre>
<pre><span class="code"><a id="page_453"></a>glEnableVertexAttribArray(0);</span></pre>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0]);</span></pre>
<pre><span class="code">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);</span></pre>
<pre></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<p>When defining a vertex array object, specific vertex buffer objects can be bound to specific vertex attributes (or inputs) in shader code. Recall the use of</p>
<pre><span class="code">layout(location=0) in vec3 in_Position</span></pre>
<p>in the passthrough vertex shader. This syntax indicate that the shader variable will receive its data from attribute index 0 in the bound vertex array object. In host code, the mapping is created using the</p>
<pre><span class="code">glEnableVertexAttribArray(0);</span></pre>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0]);</span></pre>
<pre><span class="code">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);</span></pre>
<p>calls. The first call enables the vertex attribute index (in this case, 0). The next two calls connect the previously defined vertex buffer object that holds the vertices to the vertex attribute itself. Because <span class="code">glVertexAttribPointer</span> utilizes the currently bound VBO, it is important that the <span class="code">glBindBuffer</span> is issued before assigning the vertex attribute pointer. These function calls create a mapping that binds the vertices in our vertex buffer to the <span class="code">in_Position</span> variable within the vertex shader. The <span class="code">glVertexAttribPointer</span> calls seems complicated but it basically sets attribute index <span class="cBold">0</span> to hold three components (e.g., <span class="cItalic">x, y, z</span>) of <span class="code">GLfloats</span> (the 2nd and 3rd arguments) that are not normalized (the fourth argument). The fifth argument instructs OpenGL that three float values separate the starts of each vertex set. In other words, the vertices are tightly packed in the memory, one after the other. The final argument is a pointer to the data, but because a vertex buffer has been bound prior to this call, the data will be associated with the vertex buffer.</p>
<p>The previous steps that initialize and construct the vertex array object, the vertex buffer objects, and the shaders should all be executed prior to entering the display loop. All memory from the vertex buffer will have been transferred to the GPU and the vertex array objects will make the connection between the data and shader input variable indexes. In the display loop, the following calls will trigger the processing of the vertex array object:</p>
<pre><span class="code">glBindVertexArray(VAO);</span></pre>
<pre><span class="code">glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<p><a id="page_454"></a>Note again, that a bind call makes the vertex array object active. The call to <span class="code">glDrawArrays</span> initiates the pipeline for this geometry, describing that the geometry should be interpreted as a series of triangle primitives starting at offset 0 and only rendering three of the indices. In this example, there are only three elements in the array and the primitive is a triangle, so a single triangle will be rendered.</p>
<p>Combining all of these steps, the assembled code for the triangle would resemble the following, assuming that shader and vertex data loading are contained in external functions:</p>
<div class="Box">
<pre><span class="code">// Set the viewport once</span></pre>
<pre><span class="code">int nx, ny;</span></pre>
<pre><span class="code">glfwGetFramebufferSize(window, &amp;nx, &amp;ny);</span></pre>
<pre><span class="code">glViewport(0, 0, nx, ny);</span></pre>
<pre></pre>
<pre><span class="code">// Set clear color state</span></pre>
<pre><span class="code">glClearColor(0.0f, 0.0f, 0.0f, 1.0f) ;</span></pre>
<pre></pre>
<pre><span class="code">// Create the Shader programs, VBO, and VAO</span></pre>
<pre><span class="code">GLuint shaderID = loadPassthroughShader();</span></pre>
<pre><span class="code">GLuint VAO = loadVertexData();</span></pre>
<pre></pre>
<pre><span class="code">while (!glfwWindowShouldClose(window)) {</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span></pre>
<pre></pre>
<pre><span class="code"> glUseProgram(shaderID);</span></pre>
<pre></pre>
<pre><span class="code"> glBindVertexArray(VAO);</span></pre>
<pre><span class="code"> glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre>
<pre><span class="code"> glBindVertexArray(0);</span></pre>
<pre></pre>
<pre><span class="code"> glUseProgram(0);</span></pre>
<pre></pre>
<pre><span class="code"> // Swap front and back buffers</span></pre>
<pre><span class="code"> glfwSwapBuffers(window);</span></pre>
<pre></pre>
<pre><span class="code"> // Poll for events</span></pre>
<pre><span class="code"> glfwPollEvents() ;</span></pre>
<pre><span class="code"> if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span></pre>
<pre><span class="code"> glfwSetWindowShouldClose(window, 1);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-3">Figure 17.3</a> shows the result of using the shaders and vertex state to render the canonical view volume triangle.</p>
<div id="art_Dest_fig_17-3" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-3"></a><span class="cBold">Figure 17.3</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-3.png" alt="Figure showing the canonical triangle rendered using the simple vertex and fragment shaders." width="406" height="404" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-3.png"></p>
<p class="Text figcaption">The canonical triangle rendered using the simple vertex and fragment shaders.</p>
</div>
<h2><a id="sec17-11"></a><a id="page_455"></a>17.11 Transformation Matrices</h2>
<p>Current versions of OpenGL have removed the matrix stacks that were once used to reference the projection and modelview matrices from the hardware. Because these matrix stacks no longer exist, the programmer must write matrix code that can be transferred to vertex shaders where the transformations will occur. That initially may seem challenging. However, several libraries and toolkits have been developed to assist with cross-platform development of OpenGL code. One of these libraries, GLM, or OpenGL Mathematics, has been developed to track the OpenGL and GLSL specifications closely so that interoperation between GLM and the hardware will work seamlessly.</p>
<h3><a id="sec17-11-1"></a>17.11.1 GLM</h3>
<p>GLM provides several basic math types useful to computer graphics. For our purposes, we will focus on just a few types and a handful of functions that make use of matrix transforms within the shaders easy. A few types that will be used include the following:</p>
<ul>
<li class="LX"><span class="cBold">glm::vec3</span>—a compact array of 3 floats that can be accessed using the same component-wise access found in the shaders;</li>
<li class="LX"><span class="cBold">glm::vec4</span>—a compact array of 4 floats that can be accessed using the same component-wise access found in the shaders;</li>
<li class="LX"><span class="cBold">glm::mat4</span>—a 4 × 4 matrix storage represented as 16 floats. The matrix is stored in column-major format.</li>
</ul>
<p>Similarly, GLM provides functions for creating the projection matrices, <span class="cBold">M</span><span class="cSubscript">orth</span> and <span class="cBold">M</span><span class="cSubscript">p</span>, as well as functions for generating the view matrix, <span class="cBold">M</span><span class="cSubscript">cam</span>:</p>
<ul>
<li class="LX"><span class="cBold">glm::ortho</span> creates a 4 × 4 orthographic projection matrix.</li>
<li class="LX"><span class="cBold">glm::perspective</span> creates the 4 × 4 perspective matrix.</li>
<li class="LX"><span class="cBold">glm::lookAt</span> creates the 4 × 4 homogeneous transform that translates and orients the camera.</li>
</ul>
<h3><a id="page_456"></a><a id="sec17-11-2"></a>17.11.2 Using an Orthographic Projection</h3>
<p>A simple extension to the previous example would be to place the triangle vertices into a more flexible coordinate system and render the scene using an orthographic projection. The vertices in the previous example could become:</p>
<pre><span class="code">GLfloat vertices[] = {-3.0f, -3.0f, 0.0f, 3.0f, -3.0f, 0.0f, 0.0f, 3.0f, 0.0f};</span></pre>
<p>Using GLM, an orthographic projection can be created easily on the host. For instance,</p>
<pre><span class="code">glm::mat4 projMatrix = glm::ortho(-5.0f, 5.0f, -5.0, 5.0, -10.0f, 10.0f);</span></pre>
<p>The projection matrix can then be applied to each vertex transforming it into clip coordinates. The vertex shader will be modified to perform this operation:</p>
<p class="Equation"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-651-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot; id=&quot;eq_726&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;canon&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;orth&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mstyle&gt;&lt;mtext&gt;.&lt;/mtext&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="eq_726" overflow="scroll" style="width: 7.663em; display: inline-block;"><span style="display: inline-block; position: relative; width: 7.406em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.339em, 1007.31em, 2.47em, -1000.01em); top: -2.157em; left: 0em;"><span class="mrow" id="MathJax-Span-34819"><span class="mrow" id="MathJax-Span-34820"><span class="msub" id="MathJax-Span-34821"><span style="display: inline-block; position: relative; width: 2.779em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.83em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34822"><span class="mrow" id="MathJax-Span-34823"><span class="mi" id="MathJax-Span-34824" style="font-family: MathJax_Main-bold;">V</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.877em;"><span class="mrow" id="MathJax-Span-34825"><span class="mtext" id="MathJax-Span-34826" style="font-size: 70.7%; font-family: MathJax_Main;">canon</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-34827" style="font-family: MathJax_Main; padding-left: 0.26em;">=</span><span class="msub" id="MathJax-Span-34828" style="padding-left: 0.26em;"><span style="display: inline-block; position: relative; width: 2.47em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34829"><span class="mrow" id="MathJax-Span-34830"><span class="mi" id="MathJax-Span-34831" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34832"><span class="mtext" id="MathJax-Span-34833" style="font-size: 70.7%; font-family: MathJax_Main;">orth</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mstyle" id="MathJax-Span-34834"><span class="mrow" id="MathJax-Span-34835"><span class="mi" id="MathJax-Span-34836" style="font-family: MathJax_Main-bold;">v</span></span></span><span class="mtext" id="MathJax-Span-34837" style="font-family: MathJax_Main;">.</span></span></span><span style="display: inline-block; width: 0px; height: 2.162em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.209em; border-left: 0px solid; width: 0px; height: 0.956em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_726"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>V</mi></mstyle><mrow><mtext>canon</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>orth</mtext></mrow></msub><mstyle mathvariant="bold" mathsize="normal"><mi>v</mi></mstyle><mtext>.</mtext></mrow></math></span></span><script type="math/mml" id="MathJax-Element-651"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_726"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>V</mi></mstyle><mrow><mtext>canon</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>orth</mtext></mrow></msub><mstyle mathvariant="bold" mathsize="normal"><mi>v</mi></mstyle><mtext>.</mtext></mrow></math></script></p>
<p>This computation will occur in a modified vertex shader that uses <span class="cItalic">uniform</span> variables to communicate data from the host to the device. Uniform variables represent static data that is invariant across the execution of a shader program. The data is the same for all elements and remains static. However, uniform variables can be modified by an application between executions of a shader. This is the primary mechanism that data within the host application can communicate changes to shader computations. Uniform data often represent the graphics state associated with an application. For instance, the projection, view, or model matrices can be set and accessed through uniform variables. Information about light sources within a scene may also be obtained through uniform variables.</p>
<p>Modifying the vertex shader requires adding a uniform variable to hold the projection matrix. We can use GLSL’s <span class="code">mat4</span> type to store this data. The projection matrix can then be used naturally to tranform the incoming vertices into the canonical coordinate system:</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre></pre>
<pre><span class="code">layout (location=0) in vec3 in_Position;</span></pre>
<pre><span class="code">uniform mat4 projMatrix;</span></pre>
<pre></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> gl_Position = projMatrix * vec4(in_Position, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p><a id="page_457"></a>The application code need only transfer the uniform variable from the host memory (a GLM mat4) into the device’s shader program (a GLSL mat4). This is easy enough, but requires that the host side of the application acquire a handle to the uniform variable after the shader program has been linked. For instance, to obtain a handle to the projMatrix variable, the following call would be issued once, after shader program linking is complete:</p>
<pre><span class="code">GLint pMatID = glGetUniformLocation(shaderProgram, "projMatrix");</span></pre>
<p>The first argument is the shader program object handle and the second argument is the character string of the variable name in the shader. The id can then be used with a variety of OpenGL <span class="code">glUniform</span> function call to transfer the memory on the host into the device. However, shader programs must first be bound prior to setting the value related to a uniform variable. Also, because GLM is used to store the projection matrix on the host, a GLM helper function will be used to obtain a pointer to the underlying matrix, and allow the copy to proceed.</p>
<pre><span class="code">glUseProgram(shaderID);</span></pre>
<pre></pre>
<pre><span class="code">glUniformMatrix4fv(pMatID, 1, GL_FALSE, glm::value_ptr(projMatrix));</span></pre>
<pre></pre>
<pre><span class="code">glBindVertexArray(VAO);</span></pre>
<pre><span class="code">glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<pre></pre>
<pre><span class="code">glUseProgram(0);</span></pre>
<p>Notice the form that glUniform takes. The function name ends with characters that help define how it is used. In this case, a single 4 × 4 matrix of floats is being tranferred into the uniform variable. The v indicates that an array contains the data, rather than passing by value. The third argument lets OpenGL know whether the matrix should be transposed (a potentially handy feature), and the last argument is a pointer to the memory where the matrix resides.</p>
<p>By this section of the chapter, you should have a sense for the role that shaders and vertex data play in rendering objects with OpenGL. Shaders, in particular, form a very important role in modern OpenGL. The remaining sections will further explore the role of shaders in rendering scenes, atempting to build upon the role that shaders play in other rendering styles presented in this book.</p>
<h2><a id="sec17-12"></a>17.12 Shading with Per-Vertex Attributes</h2>
<p>The previous examples specified a single triangle with no additional data. Vertex attributes, such as normal vectors, texture coordinates, or even colors, can be<a id="page_458"></a> interleaved with the vertex data in a vertex buffer. The memory layout is straightforward. Below, the color of each vertex is set after each vertex in the array. Three components are used to represent the red, green, and blue channels. Allocating the vertex buffer is identical with the exception being that the size of the array is now 18 <span class="code">GLfloats</span> instead of 9.</p>
<pre><span class="code">GLfloat vertexData[] = {0.0f, 3.0f, 0.0f, 1.0f, 1.0f, 0.0f, -3.0f,</span></pre>
<pre><span class="code">-3.0f, 0.0f, 0.0f, 1.0f, 1.0f, 3.0f, -3.0f, 0.0f, 1.0f, 0.0f, 1.0f};</span></pre>
<p>The vertex array object specification is different. Because the color data is interleaved between vertices, the vertex attribute pointers must stride across the data appropriately. The second vertex attribute index must also be enabled. Building off the previous examples, we construct the new VAO as follows:</p>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, m_triangleVBO[0]);</span></pre>
<pre></pre>
<pre><span class="code">glEnableVertexAttribArray(0);</span></pre>
<pre><span class="code">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), 0);</span></pre>
<pre></pre>
<pre><span class="code">glEnableVertexAttribArray(1);</span></pre>
<pre><span class="code">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (const GLvoid *)12);</span></pre>
<p>A single VBO is used and bound prior to setting the attributes since both vertex and color data are contained within the VBO. The first vertex attribute is enabled at index 0, which will represent the vertices in the shader. Note that the stride (the 5th argument) is different as the vertices are separated by six floats (e.g., the <span class="cItalic">x, y, z</span> of the vertex followed by the <span class="cItalic">r, g, b</span> of the color). The second vertex attribute index is enabled and will represent the vertex color attributes in the shader at location 1. It has the same stride, but the last argument now represents the pointer offset for the start of the first color value. While 12 is used in the above example, this is identical to stating 3 * <span class="code">sizeof(GLfloat)</span>. In other words, we need to jump across the three floats representing the vertex <span class="cItalic">x, y, z</span> values to locate the first color attribute in the array.</p>
<p>The shaders for this example are only slightly modified. The primary differences in the vertex shader (shown below) are (1) the second attribute, color, is at location 1 and (2) <span class="code">vColor</span> is an output variable that is set in the main body of the vertex shader.</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre></pre>
<pre><span class="code">layout (location=0) in vec3 in_Position;</span></pre>
<pre><span class="code">layout (location=1) in vec3 in_Color;</span></pre>
<pre><span class="code"><a id="page_459"></a>out vec3 vColor;</span></pre>
<pre></pre>
<pre><span class="code">uniform mat4 projMatrix;</span></pre>
<pre></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> vColor = in_Color;</span></pre>
<pre><span class="code"> gl_Position = projMatrix * vec4(in_Position, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>Recall that the keywords <span class="code">in</span> and <span class="code">out</span> refer to the flow of data between shaders. Data that flows out of the vertex shader becomes input data in the connected fragment shader, provided that the variable names match up. Moreover, out variables that are passed to fragment shaders are interpolated across the fragments using barycentric interpolation. Some modification of the interpolation can be achieved with additional keywords, but this detail will be left to the reader. In this example, three vertices are specified, each with a specific color value. Within the fragment shader, the colors will be interpolated across the face of the triangle.</p>
<p>The fragment shader changes are simple. The <span class="code">vColor</span> variable that was set and passed <span class="cItalic">out</span> of the vertex shader now becomes an <span class="cItalic">in</span> variable. As fragments are processed, the <span class="code">vColor vec3</span> will contain the correctly interpolated values based on the location of the fragment within the triangle.</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre><span class="code">layout(location=0) out vec4 fragmentColor;</span></pre>
<pre><span class="code">in vec3 vColor;</span></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> fragmentColor = vec4(vColor, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>The image that results from running this shader with the triangle data is shown in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-4">Figure 17.4</a>.</p>
<div id="art_Dest_fig_17-4" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-4"></a><span class="cBold">Figure 17.4</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-4.png" alt="Figure showing setting the colors of each vertex in the vertex shader and passing the data to the fragment shader results in barycentric interpolation of the colors." width="600" height="600" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-4.png"></p>
<p class="Text figcaption">Setting the colors of each vertex in the vertex shader and passing the data to the fragment shader results in barycentric interpolation of the colors.</p>
</div>
<h3><a id="sec17-12-1"></a>17.12.1 Structs of Vertex Data</h3>
<p>The previous example illustrates the interleaving of data in an array. Vertex buffers can be used in a variety of ways, including separate vertex buffers for different model attributes. Interleaving data has advantages as the attributes associated with a vertex are near the vertex in memory and can likely take advantage<a id="page_460"></a> of memory locality when operating in the shaders. While the use of these interleaved arrays is straightforward, it can become cumbersome to manage large models in this way, especially as data structures are used for building robust (and sustainable) software infrastructure for graphics (see <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C012.xhtml">Chapter 12</a>). It is rather simple to store vertex data as vectors of structs that contain the vertex and any related attributes. When done this way, the structure need only be mapped into the vertex buffer. For instance, the following structure contains the vertex position and vertex color, using GLM’s vec3 type:</p>
<pre><span class="code">struct vertexData</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> glm::vec3 pos;</span></pre>
<pre><span class="code"> glm::vec3 color;</span></pre>
<pre><span class="code">};</span></pre>
<pre><span class="code">std::vector&lt; vertexData &gt; modelData;</span></pre>
<p>The STL vector will hold all vertices related to all the triangles in the model. We will continue to use the same layout for triangles as in previous examples, which is a basic triangle strip. Every three vertices represents a triangle in the list. There are other data organizations that can be used with OpenGL, and <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C012.xhtml">Chapter 12</a> presents other options for organizing data more efficiently.</p>
<p>Once the data is loaded into the vector, the same calls used before load the data into the vertex buffer object:</p>
<pre><span class="code">int numBytes = modelData.size() * sizeof(vertexData);</span></pre>
<pre><span class="code"><a id="page_461"></a>glBufferData(GL_ARRAY_BUFFER, numBytes, modelData.data(), GL_STATIC_DRAW);</span></pre>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, 0);</span></pre>
<p>STL vectors store data contiguously. The <span class="code">vertexData</span> struct used above is represented by a flat memory layout (it does not contain pointers to other data elements) and is contiguous. However, the STL vector is an abstraction and the pointer that references the underlying memory must be queried using the <span class="code">data</span>() member. That pointer is provided to the call to <span class="code">glBufferData</span>. Attribute assignment in the vertex array object is identical as the locality of the vertex attributes remains the same.</p>
<h2><a id="sec17-13"></a>17.13 Shading in the Fragment Processor</h2>
<p>The graphics pipeline chapter (<a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C008.xhtml">Chapter 8</a>) and the surface shading chapter (<a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C010.xhtml">Chapter 10</a>) do a nice job of describing and illustrating the effects of per-vertex and per-fragment shading as they relate to rasterization and shading in general. With modern graphics hardware, applying shading algorithms in the fragment processor produces better visual results and more accurately approximates lighting. Shading that is computed on a per-vertex basis is often subject to visual artifacts related to the underlying geometry tessellation. In particular, per-vertex based shading often fails to approximate the appropriate intensities across the face of the triangle since the lighting is only being calculated at each vertex. For example, when the distance to the light source is small, as compared with the size of the face being shaded, the illumination on the face will be incorrect. <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-5">Figure 17.5</a> illustrates this situation. The center of the triangle will not be illuminated brightly, despite being very close to the light source, since the lighting on the vertices, which are far from the light source, are used to interpolate the shading across the face. Of course, increasing the tessellation of the geometry can improve the visuals. However, this solution is of limited use in real-time graphics as the added geometry required for more accurate illumination can result in slower rendering.</p>
<div id="art_Dest_fig_17-5" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-5"></a><span class="cBold">Figure 17.5</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-5.png" alt="Figure showing the distance to the light source is small relative to the size of the triangle." width="410" height="495" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-5.png"></p>
<p class="Text figcaption">The distance to the light source is small relative to the size of the triangle.</p>
</div>
<p>Fragment shaders operate on the fragments that emerge from rasterization after vertices have been transformed and clipped. Generally speaking, fragment shaders must output a value that is written to a framebuffer. Often times, this is the color of the pixel. If the depth test is enabled, the fragment’s depth value will be used to control whether the color and its depth are written to the framebuffer memory. The data that fragment shaders use for computation comes from various sources:</p>
<ul>
<li class="LX"><span class="cBold">Built-in OpenGL variables.</span> These variables are provided by the system. Examples of fragment shader variables include <span class="code">gl_FragCoord</span> or<a id="page_462"></a> <span class="code">gl_FrontFacing</span>. These variables can change based on revisions to OpenGL and GLSL, so it is advised that you check the specification for the version of OpenGL and GLSL that you are targeting.</li>
<li class="LX"><span class="cBold">Uniform variables.</span> Uniform variables are transferred from the host to the device and can change as needed based on user input or changing simulation state in the application. These variables are declared and defined by the programmer for use within both vertex and fragment shaders. The projection matrix in the previous vertex shader examples was communicated to the shader via a uniform variable. If needed, the same uniform variable names can be used within both vertex and fragment shaders.</li>
<li class="LX"><span class="cBold">Input variables.</span> <span class="cItalic">Input</span> variables are specified in the fragment shader with the prefixed keyword in. Recall that data can flow into and out of shaders. Vertex shaders can output data to the next shader stage using the out keyword (e.g., <span class="code">out vec3 vColor</span>, in a previous example). The outputs are linked to inputs when the next stage uses an in keyword followed by the same type and name qualifiers (e.g., in <span class="code">vec3 vColor</span> in the previous example’s corresponding fragment shader).</li>
</ul>
<p>Any data that is passed to a fragment shader through the <span class="cItalic">in-out</span> linking mechanism will vary on a per-fragment basis using barycentric interpolation. The interpolation is computed outside of the shader by the graphics hardware. Within this infrastructure, fragment shaders can be used to perform per-fragment shading algorithms that evaluate specific equations across the face of the triangle. Vertex shaders provide support computations, transforming vertices and staging intermediate per-vertex values that will be interpolated for the fragment code.</p>
<p>The following shader program code implements per-fragment, Blinn-Phong shading. It brings together much of what has been presented in this chapter thus far and binds it to the shader descriptions from <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C004.xhtml">Chapter 4</a>. An interleaved vertex buffer is used to contain the vertex position and normal vectors. These values manifest in the vertex shader as vertex array attributes for index 0 and index 1. The shading computations that occur in the fragment shader code are performed in camera coordinates (sometimes referred to as eye-space).</p>
<h3><a id="sec17-13-1"></a>17.13.1 Blinn-Phong Shader Program: Vertex Shader</h3>
<p>The vertex shader stage of our program is used to transform the incoming vertices using the <span class="cBold">M</span><span class="cSubscript">mod</span>el and <span class="cBold">M</span><span class="cSubscript">cam</span> matrices into camera coordinates. It also uses the<a id="page_463"></a> normal matrix, (M<span class="cSuperscript">−1</span>)<span class="cSuperscript"><span class="cItalic">T</span></span>, to appropriately transform the incoming normal vector attribute. The vertex shader outputs three variables to the fragment stage:</p>
<ul>
<li class="LX"><span class="cBold"><span class="code">normal</span>.</span> The vertex’s normal vector as transformed into the camera coordinate system.</li>
<li class="LX"><span class="cBold"><span class="code">h</span>.</span> The half-vector needed for Blinn-Phong shading.</li>
<li class="LX"><span class="cBold"><span class="code">l</span>.</span> The light direction transformed into the camera coordinate system.</li>
</ul>
<p>Each of these variables will then be available for fragment computation, after applying barycentric interpolation across the three vertices in the triangle.</p>
<p>A single point light is used with this shader program. The light position and intensity is communicated to both the vertex and fragment shaders using a uniform variable. The light data is declared using GLSL’s struct qualifer, which allows variables to be grouped together in meaningful ways. Although not presented here, GLSL supports arrays and for-loop control structures, so additional lights could easily be added to this example.</p>
<p>All matrices are also provided to the vertex shader using uniform variables. For now, we will imagine that the model (or local transform) matrix will be set to the indentity matrix. In the following section, more detail will be provided to expand on how the model matrix can be specified on the host using GLM.</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre></pre>
<pre><span class="code">//</span></pre>
<pre><span class="code">// Blinn-Phong Vertex Shader</span></pre>
<pre><span class="code">//</span></pre>
<pre></pre>
<pre><span class="code">layout(location=0) in vec3 in_Position;</span></pre>
<pre><span class="code">layout(location=1) in vec3 in_Normal;</span></pre>
<pre></pre>
<pre><span class="code">out vec4 normal;</span></pre>
<pre><span class="code">out vec3 half;</span></pre>
<pre><span class="code">out vec3 lightdir;</span></pre>
<pre></pre>
<pre><span class="code">struct LightData {</span></pre>
<pre><span class="code"> vec3 position;</span></pre>
<pre><span class="code"> vec3 intensity;</span></pre>
<pre><span class="code">};</span></pre>
<pre><span class="code">uniform LightData light;</span></pre>
<pre></pre>
<pre><span class="code">uniform mat4 projMatrix;</span></pre>
<pre><span class="code">uniform mat4 viewMatrix;</span></pre>
<pre><span class="code">uniform mat4 modelMatrix;</span></pre>
<pre><span class="code">uniform mat4 normalMatrix;</span></pre>
<pre></pre>
<pre><span class="code"><a id="page_464"></a>void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> // Calculate lighting in eye space: transform the local</span></pre>
<pre><span class="code"> // position to world and then camera coordinates.</span></pre>
<pre><span class="code"> vec4 pos = viewMatrix * modelMatrix * vec4(in_Position, 1.0);</span></pre>
<pre><span class="code"> vec4 lightPos = viewMatrix * vec4(light.position, 1.0);</span></pre>
<pre></pre>
<pre><span class="code"> normal = normalMatrix * vec4(in_Normal, 0.0);</span></pre>
<pre></pre>
<pre><span class="code"> vec3 v = normalize(-pos.xyz);</span></pre>
<pre><span class="code"> lightdir = normalize(lightPos.xyz - pos.xyz);</span></pre>
<pre><span class="code"> half = normalize(v + lightdir);</span></pre>
<pre></pre>
<pre><span class="code"> gl_Position = projMatrix * pos;</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>The vertex shader’s main function first transforms the position and light position into camera coordinates using <span class="code">vec4</span> types to correspond with the 4 × 4 matrices of GLSL’s <span class="code">mat4</span>. We then transform the normal vector and store it in the out <span class="code">vec4 normal</span> variable. The view (or eye) vector and light direction vector are then calculated, which leads to the computation of the half vector needed for Blinn-Phong shading. The final computation completes the calculation of</p>
<p class="Equation"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-652-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot; id=&quot;eq_727&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;canon&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;proj&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;cam&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;model&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="eq_727" overflow="scroll" style="width: 12.959em; display: inline-block;"><span style="display: inline-block; position: relative; width: 12.548em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.339em, 1012.5em, 2.625em, -1000.01em); top: -2.157em; left: 0em;"><span class="mrow" id="MathJax-Span-34839"><span class="mrow" id="MathJax-Span-34840"><span class="msub" id="MathJax-Span-34841"><span style="display: inline-block; position: relative; width: 2.779em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.83em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34842"><span class="mrow" id="MathJax-Span-34843"><span class="mi" id="MathJax-Span-34844" style="font-family: MathJax_Main-bold;">V</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.877em;"><span class="mrow" id="MathJax-Span-34845"><span class="mtext" id="MathJax-Span-34846" style="font-size: 70.7%; font-family: MathJax_Main;">canon</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-34847" style="font-family: MathJax_Main; padding-left: 0.26em;">=</span><span class="msub" id="MathJax-Span-34848" style="padding-left: 0.26em;"><span style="display: inline-block; position: relative; width: 2.419em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34849"><span class="mrow" id="MathJax-Span-34850"><span class="mi" id="MathJax-Span-34851" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34852"><span class="mtext" id="MathJax-Span-34853" style="font-size: 70.7%; font-family: MathJax_Main;">proj</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="msub" id="MathJax-Span-34854"><span style="display: inline-block; position: relative; width: 2.419em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34855"><span class="mrow" id="MathJax-Span-34856"><span class="mi" id="MathJax-Span-34857" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34858"><span class="mtext" id="MathJax-Span-34859" style="font-size: 70.7%; font-family: MathJax_Main;">cam</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="msub" id="MathJax-Span-34860"><span style="display: inline-block; position: relative; width: 3.036em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34861"><span class="mrow" id="MathJax-Span-34862"><span class="mi" id="MathJax-Span-34863" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34864"><span class="mtext" id="MathJax-Span-34865" style="font-size: 70.7%; font-family: MathJax_Main;">model</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mstyle" id="MathJax-Span-34866"><span class="mrow" id="MathJax-Span-34867"><span class="mi" id="MathJax-Span-34868" style="font-family: MathJax_Main-bold;">v</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.162em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.368em; border-left: 0px solid; width: 0px; height: 1.115em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_727"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>V</mi></mstyle><mrow><mtext>canon</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>proj</mtext></mrow></msub><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>cam</mtext></mrow></msub><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>model</mtext></mrow></msub><mstyle mathvariant="bold" mathsize="normal"><mi>v</mi></mstyle></mrow></math></span></span><script type="math/mml" id="MathJax-Element-652"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_727"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>V</mi></mstyle><mrow><mtext>canon</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>proj</mtext></mrow></msub><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>cam</mtext></mrow></msub><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>model</mtext></mrow></msub><mstyle mathvariant="bold" mathsize="normal"><mi>v</mi></mstyle></mrow></math></script></p>
<p>by applying the projection matrix. It then sets the canonical coordinates of the vertex to the built-in GLSL vertex shader output variable <span class="code">gl_Position</span>. After this, the vertex is in clip-coordinates and is ready for rasterization.</p>
<h3><a id="sec17-13-2"></a>17.13.2 Blinn-Phong Shader Program: Fragment Shader</h3>
<p>The fragment shader computes the Blinn-Phong shading model. It receives barycentric interpolated values for the vertex normal, half vector, and light direction. Note that these variables are specified using the in keyword as they come <span class="cItalic">in</span> from the vertex processing stage. The light data is also shared with the fragment shader using the same uniform specification that was used in the vertex shader. The matrices are not required so no uniform matrix variables are declared. The material properties for the geometric model are communicated through uniform variables to specify <span class="cItalic">k</span><span class="cItalic">a</span>, <span class="cItalic">k</span><span class="cItalic">d</span>, <span class="cItalic">k</span><span class="cItalic">s</span>, <span class="cItalic">I</span><span class="cItalic">a</span>, and <span class="cItalic">p</span>. Together, the data allow the fragment shader to compute Equation 4.3:</p>
<p class="Equation"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-653-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot; id=&quot;eq_728&quot;&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msub&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mrow&gt;&lt;mtext&gt;0,&lt;/mtext&gt;&lt;mo&gt;&amp;#xA0;&amp;#xA0;&lt;/mo&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;mtext&gt;1&lt;/mtext&gt;&lt;/mrow&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/msub&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mrow&gt;&lt;mtext&gt;0,&lt;/mtext&gt;&lt;mo&gt;&amp;#xA0;&amp;#xA0;&lt;/mo&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="eq_728" overflow="scroll" style="width: 23.242em; display: inline-block;"><span style="display: inline-block; position: relative; width: 22.573em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.237em, 1022.58em, 2.573em, -1000.01em); top: -2.157em; left: 0em;"><span class="mrow" id="MathJax-Span-34870"><span class="mrow" id="MathJax-Span-34871"><span class="mi" id="MathJax-Span-34872" style="font-family: MathJax_Math-italic;">L</span><span class="mo" id="MathJax-Span-34873" style="font-family: MathJax_Main; padding-left: 0.26em;">=</span><span class="msub" id="MathJax-Span-34874" style="padding-left: 0.26em;"><span style="display: inline-block; position: relative; width: 0.979em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.52em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-34875" style="font-family: MathJax_Math-italic;">k</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.517em;"><span class="mi" id="MathJax-Span-34876" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="msub" id="MathJax-Span-34877"><span style="display: inline-block; position: relative; width: 0.877em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.52em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-34878" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.465em;"><span class="mi" id="MathJax-Span-34879" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-34880" style="font-family: MathJax_Main; padding-left: 0.208em;">+</span><span class="msub" id="MathJax-Span-34881" style="padding-left: 0.208em;"><span style="display: inline-block; position: relative; width: 0.979em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.52em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-34882" style="font-family: MathJax_Math-italic;">k</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.517em;"><span class="mi" id="MathJax-Span-34883" style="font-size: 70.7%; font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mtext" id="MathJax-Span-34884" style="font-family: MathJax_Main;">&nbsp;</span><span class="mi" id="MathJax-Span-34885" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="mtext" id="MathJax-Span-34886" style="font-family: MathJax_Main;">&nbsp;</span><span class="mi" id="MathJax-Span-34887" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-34888" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-34889" style="font-family: MathJax_Math-italic;">x</span><span class="mrow" id="MathJax-Span-34890" style="padding-left: 0.157em;"><span class="mo" id="MathJax-Span-34891" style="font-family: MathJax_Main;">(</span><span class="mrow" id="MathJax-Span-34892"><span class="mtext" id="MathJax-Span-34893" style="font-family: MathJax_Main;">0,</span><span class="mo" id="MathJax-Span-34894" style="font-family: MathJax_Main;">&nbsp;&nbsp;</span><span class="mi" id="MathJax-Span-34895" style="font-family: MathJax_Main-bold;">n</span><span class="mo" id="MathJax-Span-34896" style="font-family: MathJax_Main; padding-left: 0.208em;">⋅</span><span class="mtext" id="MathJax-Span-34897" style="font-family: MathJax_Main; padding-left: 0.208em;">1</span></span><span class="mo" id="MathJax-Span-34898" style="font-family: MathJax_Main;">)</span></span><span class="mo" id="MathJax-Span-34899" style="font-family: MathJax_Main; padding-left: 0.208em;">+</span><span class="msub" id="MathJax-Span-34900" style="padding-left: 0.208em;"><span style="display: inline-block; position: relative; width: 0.928em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.52em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-34901" style="font-family: MathJax_Math-italic;">k</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 0.517em;"><span class="mi" id="MathJax-Span-34902" style="font-size: 70.7%; font-family: MathJax_Math-italic;">s</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mtext" id="MathJax-Span-34903" style="font-family: MathJax_Main;">&nbsp;</span><span class="mi" id="MathJax-Span-34904" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="mtext" id="MathJax-Span-34905" style="font-family: MathJax_Main;">&nbsp;</span><span class="mi" id="MathJax-Span-34906" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-34907" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-34908" style="font-family: MathJax_Math-italic;">x</span><span class="msup" id="MathJax-Span-34909"><span style="display: inline-block; position: relative; width: 4.476em; height: 0px;"><span style="position: absolute; clip: rect(3.087em, 1003.92em, 4.424em, -1000.01em); top: -4.008em; left: 0em;"><span class="mrow" id="MathJax-Span-34910"><span class="mrow" id="MathJax-Span-34911"><span class="mo" id="MathJax-Span-34912" style="font-family: MathJax_Main;">(</span><span class="mrow" id="MathJax-Span-34913"><span class="mtext" id="MathJax-Span-34914" style="font-family: MathJax_Main;">0,</span><span class="mo" id="MathJax-Span-34915" style="font-family: MathJax_Main;">&nbsp;&nbsp;</span><span class="mi" id="MathJax-Span-34916" style="font-family: MathJax_Main-bold;">n</span><span class="mo" id="MathJax-Span-34917" style="font-family: MathJax_Main; padding-left: 0.208em;">⋅</span><span class="mi" id="MathJax-Span-34918" style="font-family: MathJax_Main-bold; padding-left: 0.208em;">h</span></span><span class="mo" id="MathJax-Span-34919" style="font-family: MathJax_Main;">)</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -4.47em; left: 4.013em;"><span class="mi" id="MathJax-Span-34920" style="font-size: 70.7%; font-family: MathJax_Math-italic;">p</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.162em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.315em; border-left: 0px solid; width: 0px; height: 1.168em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_728"><mrow><mi>L</mi><mo>=</mo><msub><mi>k</mi><mi>a</mi></msub><msub><mi>I</mi><mi>a</mi></msub><mo>+</mo><msub><mi>k</mi><mi>d</mi></msub><mtext>&nbsp;</mtext><mi>I</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo>(</mo><mrow><mtext>0,</mtext><mo>&nbsp;&nbsp;</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mtext>1</mtext></mrow><mo>)</mo></mrow><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mtext>&nbsp;</mtext><mi>I</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>x</mi><msup><mrow><mrow><mo>(</mo><mrow><mtext>0,</mtext><mo>&nbsp;&nbsp;</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mi mathvariant="bold">h</mi></mrow><mo>)</mo></mrow></mrow><mi>p</mi></msup></mrow></math></span></span><script type="math/mml" id="MathJax-Element-653"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_728"><mrow><mi>L</mi><mo>=</mo><msub><mi>k</mi><mi>a</mi></msub><msub><mi>I</mi><mi>a</mi></msub><mo>+</mo><msub><mi>k</mi><mi>d</mi></msub><mtext> </mtext><mi>I</mi><mtext> </mtext><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo>(</mo><mrow><mtext>0,</mtext><mo>  </mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mtext>1</mtext></mrow><mo>)</mo></mrow><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mtext> </mtext><mi>I</mi><mtext> </mtext><mi>m</mi><mi>a</mi><mi>x</mi><msup><mrow><mrow><mo>(</mo><mrow><mtext>0,</mtext><mo>  </mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mi mathvariant="bold">h</mi></mrow><mo>)</mo></mrow></mrow><mi>p</mi></msup></mrow></math></script></p>
<p>at each fragment.</p>
<div class="Box">
<pre><span class="code"><a id="page_465"></a>#version 330 core</span></pre>
<pre></pre>
<pre><span class="code">//</span></pre>
<pre><span class="code">// Blinn-Phong Fragment Shader</span></pre>
<pre><span class="code">//</span></pre>
<pre></pre>
<pre><span class="code">in vec4 normal;</span></pre>
<pre><span class="code">in vec3 half;</span></pre>
<pre><span class="code">in vec3 lightdir;</span></pre>
<pre></pre>
<pre><span class="code">layout(location=0) out vec4 fragmentColor;</span></pre>
<pre></pre>
<pre><span class="code">struct LightData {</span></pre>
<pre><span class="code"> vec3 position;</span></pre>
<pre><span class="code"> vec3 intensity;</span></pre>
<pre><span class="code">};</span></pre>
<pre><span class="code">uniform LightData light;</span></pre>
<pre></pre>
<pre><span class="code">uniform vec3 Ia;</span></pre>
<pre><span class="code">uniform vec3 ka, kd, ks;</span></pre>
<pre><span class="code">uniform float phongExp;</span></pre>
<pre></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> vec3 n = normalize(normal.xyz);</span></pre>
<pre><span class="code"> vec3 h = normalize(half);</span></pre>
<pre><span class="code"> vec3 l = normalize (lightdir);</span></pre>
<pre></pre>
<pre><span class="code"> vec3 intensity = ka * Ia</span></pre>
<pre><span class="code">    + kd * light.intensity * max (0.0, dot(n, l))</span></pre>
<pre><span class="code">    + ks * light.intensity</span></pre>
<pre><span class="code">    * pow(max (0.0, dot(n, h)), phongExp);</span></pre>
<pre><span class="code"> fragmentColor = vec4(intensity, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>The fragment shader writes the computed intensity to the fragment color output buffer. <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-6">Figure 17.6</a> illustrates several examples that show the effect of perfragment shading across varying degrees of tessellation on a geometric model. This fragment shader introduces the use of structures for holding uniform variables. It should be noted that they are user-defined structures, and in this example, the <span class="code">LightData</span> type holds only the light position and its intensity. In host code, the uniform variables in structures are referenced using the fully qualified variable name when requesting the handle to the uniform variable, as in:</p>
<div id="art_Dest_fig_17-6" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-6"></a><span class="cBold">Figure 17.6</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-6.png" alt="Figure showing per-fragment shading applied across increasing tessellation of a subdivision sphere. The specular highlight is apparent with lower tessellations." width="600" height="300" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-6.png"></p>
<p class="Text figcaption">Per-fragment shading applied across increasing tessellation of a subdivision sphere. The specular highlight is apparent with lower tessellations.</p>
</div>
<pre><span class="code">lightPosID = shader.createUniform("light.position");</span></pre>
<pre><span class="code">lightIntensityID = shader.createUniform("light.intensity");</span></pre>
<h3><a id="page_466"></a><a id="sec17-13-3"></a>17.13.3 A Normal Shader</h3>
<p>Once you have a working shader program, such as the Blinn-Phong one presented here, it is easy to expand your ideas and develop new shaders. It may also be helpful to develop a set of very specific shaders for debugging. One such shader is the normal shader program. Normal shading is often helpful to understand whether the incoming geometry is organized correctly or whether the computations are correct. In this example, the vertex shader remains the same. Only the fragment shader changes:</p>
<div class="Box">
<pre><span class="code">#version 330 core</span></pre>
<pre></pre>
<pre><span class="code">in vec4 normal;</span></pre>
<pre></pre>
<pre><span class="code">layout (location=0) out vec4 fragmentColor;</span></pre>
<pre></pre>
<pre><span class="code">void main(void)</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> // Notice the use of swizzling here to access</span></pre>
<pre><span class="code"> // only the xyz values to convert the normal vec4</span></pre>
<pre><span class="code"> // into a vec3 type !</span></pre>
<pre><span class="code"> vec3 intensity = normalize(normal.xyz) * 0.5 + 0.5;</span></pre>
<pre><span class="code"> fragmentColor = vec4(intensity, 1.0);</span></pre>
<pre><span class="code">}</span></pre>
</div>
<p>Whichever shaders you start building, be sure to comment them! The GLSL specification allows comments to be included in shader code, so leave yourself some details that can guide you later.</p>
<h2><a id="sec17-14"></a><a id="page_467"></a>17.14 Meshes and Instancing</h2>
<p>Once basic shaders are working, it’s interesting to start creating more complex scenes. Some 3D model files are simple to load and others require more effort. One simple 3D object file representation is the OBJ format. OBJ is a widely used format and several codes are available to load these types of files. The array of structs mechanism presented earlier works well for containing the OBJ data on the host. It can then easily be transferred into a VBO and vertex array objects.</p>
<p>Many 3D models are defined in their own local coordinate systems and need various transformations to align them with the OpenGL coordinate system. For instance, when the Stanford Dragon’s OBJ file is loaded into the OpenGL coordinate system, it appears lying on its side at the origin. Using GLM, we can create the model transformations to place objects within our scenes. For the dragon model, this means rotating −90 degrees about <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-654-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;inline&quot; id=&quot;ueq_78&quot;&gt;&lt;mrow&gt;&lt;mover accent=&quot;true&quot;&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo stretchy=&quot;true&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="ueq_78" style="width: 1.185em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.62em, 1001.09em, 2.265em, -1000.01em); top: -2.105em; left: 0em;"><span class="mrow" id="MathJax-Span-34922"><span class="mrow" id="MathJax-Span-34923"><span class="mover" id="MathJax-Span-34924"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.83em, 4.167em, -1000.01em); top: -4.008em; left: 0.054em;"><span class="mi" id="MathJax-Span-34925" style="font-family: MathJax_Math-italic;">X<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.345em, 1000.94em, 4.167em, -1000.01em); top: -4.83em; left: 0.105em;"><span class="mo" id="MathJax-Span-34926" style=""><span style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.111em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.05em; border-left: 0px solid; width: 0px; height: 1.485em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_78"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">→</mo></mover></mrow></math></span></span><script type="math/mml" id="MathJax-Element-654"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_78"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">→</mo></mover></mrow></math></script>, and then translating up in <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-655-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;inline&quot; id=&quot;ueq_79&quot;&gt;&lt;mrow&gt;&lt;mover accent=&quot;true&quot;&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mo stretchy=&quot;true&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="ueq_79" style="width: 1.185em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.62em, 1001.09em, 2.265em, -1000.01em); top: -2.105em; left: 0em;"><span class="mrow" id="MathJax-Span-34928"><span class="mrow" id="MathJax-Span-34929"><span class="mover" id="MathJax-Span-34930"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.78em, 4.167em, -1000.01em); top: -4.008em; left: 0.105em;"><span class="mi" id="MathJax-Span-34931" style="font-family: MathJax_Math-italic;">Y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.208em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.345em, 1000.94em, 4.167em, -1000.01em); top: -4.83em; left: 0.157em;"><span class="mo" id="MathJax-Span-34932" style=""><span style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.111em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.05em; border-left: 0px solid; width: 0px; height: 1.485em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_79"><mrow><mover accent="true"><mi>Y</mi><mo stretchy="true">→</mo></mover></mrow></math></span></span><script type="math/mml" id="MathJax-Element-655"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_79"><mrow><mover accent="true"><mi>Y</mi><mo stretchy="true">→</mo></mover></mrow></math></script>. The effective model transform becomes</p>
<p class="Equation"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-656-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot; id=&quot;eq_729&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;model&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;translate&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mtext&gt;&amp;#xA0;&lt;/mtext&gt;&lt;msub&gt;&lt;mstyle mathvariant=&quot;bold&quot; mathsize=&quot;normal&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mstyle&gt;&lt;mrow&gt;&lt;mtext&gt;rotX&lt;/mtext&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="eq_729" overflow="scroll" style="width: 11.725em; display: inline-block;"><span style="display: inline-block; position: relative; width: 11.365em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.288em, 1011.32em, 2.47em, -1000.01em); top: -2.105em; left: 0em;"><span class="mrow" id="MathJax-Span-34934"><span class="mrow" id="MathJax-Span-34935"><span class="msub" id="MathJax-Span-34936"><span style="display: inline-block; position: relative; width: 3.036em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34937"><span class="mrow" id="MathJax-Span-34938"><span class="mi" id="MathJax-Span-34939" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34940"><span class="mtext" id="MathJax-Span-34941" style="font-size: 70.7%; font-family: MathJax_Main;">model</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-34942" style="font-family: MathJax_Main; padding-left: 0.26em;">=</span><span class="msub" id="MathJax-Span-34943" style="padding-left: 0.26em;"><span style="display: inline-block; position: relative; width: 3.91em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34944"><span class="mrow" id="MathJax-Span-34945"><span class="mi" id="MathJax-Span-34946" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34947"><span class="mtext" id="MathJax-Span-34948" style="font-size: 70.7%; font-family: MathJax_Main;">translate</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mtext" id="MathJax-Span-34949" style="font-family: MathJax_Main;">&nbsp;</span><span class="msub" id="MathJax-Span-34950"><span style="display: inline-block; position: relative; width: 2.625em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1001.04em, 4.167em, -1000.01em); top: -4.008em; left: 0em;"><span class="mstyle" id="MathJax-Span-34951"><span class="mrow" id="MathJax-Span-34952"><span class="mi" id="MathJax-Span-34953" style="font-family: MathJax_Main-bold;">M</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.854em; left: 1.082em;"><span class="mrow" id="MathJax-Span-34954"><span class="mtext" id="MathJax-Span-34955" style="font-size: 70.7%; font-family: MathJax_Main;">rotX</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-34956" style="font-family: MathJax_Main;">,</span></span></span><span style="display: inline-block; width: 0px; height: 2.111em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.262em; border-left: 0px solid; width: 0px; height: 1.009em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_729"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>model</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>translate</mtext></mrow></msub><mtext>&nbsp;</mtext><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>rotX</mtext></mrow></msub><mo>,</mo></mrow></math></span></span><script type="math/mml" id="MathJax-Element-656"><math xmlns="http://www.w3.org/1998/Math/MathML" overflow="scroll" id="eq_729"><mrow><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>model</mtext></mrow></msub><mo>=</mo><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>translate</mtext></mrow></msub><mtext> </mtext><msub><mstyle mathvariant="bold" mathsize="normal"><mi>M</mi></mstyle><mrow><mtext>rotX</mtext></mrow></msub><mo>,</mo></mrow></math></script></p>
<p>and the dragon is presented upright and above the ground plane, as shown in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-7">Figure 17.7</a>. To do this we utilize several functions from GLM for generating local model transforms:</p>
<div id="art_Dest_fig_17-7" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-7"></a><span class="cBold">Figure 17.7</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-7.png" alt="Figure showing images are described from left to right. The default local orientation of the dragon, lying on its side. After a -90 degree rotation about X→, the dragon is upright but still centered about the origin. Finally, after applying a translation of 1.0 in Y→, the dragon is ready for instancing." width="600" height="197" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-7.png"></p>
<p class="Text figcaption">Images are described from left to right. The default local orientation of the dragon, lying on its side. After a -90 degree rotation about <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-657-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;inline&quot; id=&quot;ueq_80&quot;&gt;&lt;mrow&gt;&lt;mover accent=&quot;true&quot;&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo stretchy=&quot;true&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="ueq_80" style="width: 1.185em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.62em, 1001.09em, 2.265em, -1000.01em); top: -2.105em; left: 0em;"><span class="mrow" id="MathJax-Span-34958"><span class="mrow" id="MathJax-Span-34959"><span class="mover" id="MathJax-Span-34960"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.83em, 4.167em, -1000.01em); top: -4.008em; left: 0.054em;"><span class="mi" id="MathJax-Span-34961" style="font-family: MathJax_Math-italic;">X<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.345em, 1000.94em, 4.167em, -1000.01em); top: -4.83em; left: 0.105em;"><span class="mo" id="MathJax-Span-34962" style=""><span style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.111em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.05em; border-left: 0px solid; width: 0px; height: 1.485em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_80"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">→</mo></mover></mrow></math></span></span><script type="math/mml" id="MathJax-Element-657"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_80"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">→</mo></mover></mrow></math></script>, the dragon is upright but still centered about the origin. Finally, after applying a translation of 1.0 in <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-658-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;inline&quot; id=&quot;ueq_81&quot;&gt;&lt;mrow&gt;&lt;mover accent=&quot;true&quot;&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mo stretchy=&quot;true&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="ueq_81" style="width: 1.185em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.62em, 1001.09em, 2.265em, -1000.01em); top: -2.105em; left: 0em;"><span class="mrow" id="MathJax-Span-34964"><span class="mrow" id="MathJax-Span-34965"><span class="mover" id="MathJax-Span-34966"><span style="display: inline-block; position: relative; width: 1.134em; height: 0px;"><span style="position: absolute; clip: rect(3.19em, 1000.78em, 4.167em, -1000.01em); top: -4.008em; left: 0.105em;"><span class="mi" id="MathJax-Span-34967" style="font-family: MathJax_Math-italic;">Y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.208em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.345em, 1000.94em, 4.167em, -1000.01em); top: -4.83em; left: 0.157em;"><span class="mo" id="MathJax-Span-34968" style=""><span style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.111em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.05em; border-left: 0px solid; width: 0px; height: 1.485em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_81"><mrow><mover accent="true"><mi>Y</mi><mo stretchy="true">→</mo></mover></mrow></math></span></span><script type="math/mml" id="MathJax-Element-658"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" id="ueq_81"><mrow><mover accent="true"><mi>Y</mi><mo stretchy="true">→</mo></mover></mrow></math></script>, the dragon is ready for instancing.</p>
</div>
<ul>
<li class="LX"><span class="cBold">glm::translate</span> creates a translation matrix.</li>
<li class="LX"><span class="cBold">glm::rotate</span> creates a rotation matrix, specified in either degrees or radians about a specific axis.</li>
<li class="LX"><span class="cBold">glm::scale</span> creates a scale matrix.</li>
</ul>
<p><a id="page_468"></a>We can apply these functions to create the model transforms and pass the model matrix to the shader using uniform variables. The Blinn-Phong vertex shader contains instructions that apply the local transform to the incoming vertex. The following code shows how the dragon model is rendered:</p>
<div class="Box">
<pre><span class="code">glUseProgram(BlinnPhongShaderID);</span></pre>
<pre></pre>
<pre><span class="code">// Describe the Local Transform Matrix</span></pre>
<pre><span class="code">glm::mat4 modelMatrix = glm::mat4(1.0); // Identity Matrix</span></pre>
<pre><span class="code">modelMatrix = glm::translate(modelMatrix, glm::vec3 (0.0f, 1.0f, ↩</span></pre>
<pre><span class="code"> 0.0f));</span></pre>
<pre><span class="code">float rot = (-90.0f / 180.0f) * M_PI;</span></pre>
<pre><span class="code">modelMatrix = glm:: rotate(modelMatrix, rot, glm::vec3(1, 0, 0));</span></pre>
<pre></pre>
<pre><span class="code">// Set the Normal Matrix</span></pre>
<pre><span class="code">glm::mat4 normalMatrix = glm::transpose (glm:: inverse (viewMatrix↩</span></pre>
<pre><span class="code"> * modelMatrix)) ;</span></pre>
<pre></pre>
<pre><span class="code">// Pass the matrices to the GPU memory</span></pre>
<pre><span class="code">glUniformMatrix4fv (nMatID, 1, GL_FALSE, glm::value_ptr(↩</span></pre>
<pre><span class="code"> normalMatrix));</span></pre>
<pre><span class="code">glUniformMatrix4fv (pMatID, 1, GL_FALSE, glm:: value_ptr(projMatrix↩</span></pre>
<pre><span class="code">));</span></pre>
<pre><span class="code">glUniformMatrix4fv (vMatID, 1, GL_FALSE, glm::value_ptr(viewMatrix↩</span></pre>
<pre><span class="code">));</span></pre>
<pre><span class="code">glUniformMatrix4fv (mMatID, 1, GL_FALSE, glm::value_ptr(↩</span></pre>
<pre><span class="code"> modelMatrix));</span></pre>
<pre></pre>
<pre><span class="code">// Set material for this object</span></pre>
<pre><span class="code">glm::vec3 kd(0.2, 0.2, 1.0);</span></pre>
<pre><span class="code">glm::vec3 ka = kd * 0.15f;</span></pre>
<pre><span class="code">glm::vec3 ks(1.0, 1.0, 1.0);</span></pre>
<pre><span class="code">float phongExp = 32.0;</span></pre>
<pre></pre>
<pre><span class="code">glUniform3fv(kaID, 1, glm::value_ptr(ka));</span></pre>
<pre><span class="code">glUniform3fv(kdID, 1, glm::value_ptr(kd));</span></pre>
<pre><span class="code">glUniform3fv(ksID, 1, glm::value_ptr(ks));</span></pre>
<pre><span class="code">glUniform1f(phongExpID, phongExp);</span></pre>
<pre></pre>
<pre><span class="code">// Process the object and note that modelData.size() holds</span></pre>
<pre><span class="code">// the number of vertices, not the number of triangles!</span></pre>
<pre><span class="code">glBindVertexArray(VAO);</span></pre>
<pre><span class="code">glDrawArrays(GL_TRIANGLES, 0, modelData.size());</span></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<pre></pre>
<pre><span class="code">glUseProgram(0);</span></pre>
</div>
<h3><a id="page_469"></a><a id="sec17-14-1"></a>17.14.1 Instancing Models</h3>
<p>Instancing with OpenGL is implemented differently than instancing with the ray tracer. With the ray tracer, rays are inversely transformed into the local space of the object using the model transform matrix. With OpenGL, instancing is performed by loading a single copy of the object as a vertex array object (with associated vertex buffer objects), and then reusing the geometry as needed. Like the ray tracer, only a single object is loaded into memory, but many may be rendered.</p>
<p>Modern OpenGL nicely supports this style of instancing because vertex shaders can (and must) compute the necessary transformations to transform vertices into clip coordinates. By writing generalized shaders that embed these transformations, such as presented with the Blinn-Phong vertex shader, models can be rerendered with the same underlying local geometry. Different material types and transforms can be queried from higher-level class structures to populate the uniform variables passed from host to device each frame. Animations and interactive control are also easily created as the model transforms can change over time across the the display loop iteration. <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-8">Figures 17.8</a> and <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-9">17.9</a> use the memory footprint of one dragon, yet render three different dragon models to the screen.</p>
<div id="art_Dest_fig_17-8" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-8"></a><span class="cBold">Figure 17.8</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-8.png" alt="Figure showing the results of running the Blinn-Phong shader program on the three dragons using uniform variables to specify material properties and transformations." width="405" height="404" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-8.png"></p>
<p class="Text figcaption">The results of running the Blinn-Phong shader program on the three dragons using uniform variables to specify material properties and transformations.</p>
</div>
<div id="art_Dest_fig_17-9" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-9"></a><span class="cBold">Figure 17.9</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-9.png" alt="Figure showing setting the uniform variable ks = (0, 0, 0) in the Blinn-Phong shader program produces Lambertian shading." width="405" height="404" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-9.png"></p>
<p class="Text figcaption">Setting the uniform variable <span class="cItalic">k</span><span class="cItalic">s</span> = (0, 0, 0) in the Blinn-Phong shader program produces Lambertian shading.</p>
</div>
<h2><a id="sec17-15"></a>17.15 Texture Objects</h2>
<p>Textures are an effective means to manipulate visual effects with OpenGL shaders. They are used extensively with many hardware-based graphics algorithms and OpenGL supports them natively with <span class="cItalic">Texture objects</span>. Like the previous OpenGL concepts, texture objects must be allocated and initialized by copying data on the host to the GPU memory and setting OpenGL state. Texture coordinates are often integrated into the vertex buffer objects and passed as vertex attributes to shader programs. Fragment shaders typically perform the texture lookup function using interpolated texture coordinate passed from the vertex shaders.</p>
<p>Textures are rather simple to add to your code if you already have working shader and vertex array objects. The standard OpenGL techniques for creating objects on the hardware are used with textures. However, the source of the texture data must first be determined. Data can either be loaded from a file (e.g., PNG, JPG, EXR, or HDR image file formats) or generated procedurally on the host (and even on the GPU). After the data is loaded into host memory, the data is copied to GPU memory, and optionally, OpenGL state associated with textures can be set. OpenGL texture data is loaded as a linear buffer of memory containing the data used for textures. Texture lookups on the hardware can be 1D, 2D, or 3D queries. Regardless of the texture dimension query, the data is loaded onto the<a id="page_470"></a> memory in the same way, using linearly allocated memory on the host. In the following example, the process of loading data from an image file (or generating it procedurally) is left to the reader, but variable names are provided that match what might be present if an image is loaded (e.g., imgData, imgWidth, imgHeight).</p>
<pre><span class="code">float *imgData = new float[imgHeight * imgWidth * 3];</span></pre>
<pre><span class="code">...</span></pre>
<pre><span class="code">GLuint texID;</span></pre>
<pre><span class="code">glGenTextures(1, &amp;texID);</span></pre>
<pre><span class="code">glBindTexture(GL_TEXTURE_2D, texID);</span></pre>
<pre><span class="code">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);</span></pre>
<pre><span class="code">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);</span></pre>
<pre><span class="code">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span></pre>
<pre><span class="code">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span></pre>
<pre><span class="code">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, imgWidth, imgHeight, 0,</span></pre>
<pre><span class="code">    GL_RGB, GL_FLOAT, imgData);</span></pre>
<pre><span class="code">glBindTexture(GL_TEXTURE_2D, 0);</span></pre>
<pre><span class="code">delete [] imgData;</span></pre>
<p>The example presented here highlights how to set up and use basic 2D OpenGL textures with shader programs. The process for creating OpenGL objects should be familiar by now. A handle (or ID) must be generated on the device to refer to the texture object (e.g., in this case, <span class="code">texID</span>). The id is then bound to allow any subsequent texture state operations to affect the state of the texture. A fairly extensive set of OpenGL texture state and parameters exist that affect texture coordinate interpretation and texture lookup filtering. Various texture targets exist with graphics hardware. In this case, the texture target is specified as <span class="code">GL_TEXTURE_2D</span> and will appear as the first argument in the texture-related functions. For OpenGL this particular texture target implies that texture coordinates will be specified in a device normalized manner (i.e., in the range of [0, 1]). Moreover, texture data must be allocated so that the width and height dimensions are powers of two (e.g., 512 × 512,1024 × 512, etc.). Texture parameters are set for the currently bound texture by calling <span class="code">glTexParameter</span>. This signature for this function takes on a variety of forms depending on the types of data being set. In this case, texture coordinates will be clamped by the hardware to the explicit range [0,1]. The minifying and magnifying filters of OpenGL texture objects are set to use linear filtering (rather than nearest neighbor - <span class="code">GL_NEAREST</span>) automatically when performing texture lookups. <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C011.xhtml">Chapter 11</a> provides substantial details on texturing, including details about the filtering that can occur with texture lookups. Graphics hardware can perform many of these operations automatically by setting the associated texture state.</p>
<p>Finally, the call to <span class="code">glTexImage2D</span> performs the host to device copy for the texture. There are several arguments to this function, but the overall operation is to<a id="page_471"></a> allocate space on the graphics card (e.g., <span class="cItalic">imageWidth</span> X <span class="cItalic">imgHeight</span>) of three floats (7th and 8th arguments: <span class="code">GL_RGB</span> and <span class="code">GL_FLOAT</span>) and copy the linear texture data to the hardware (e.g., <span class="cItalic">imgData</span> pointer). The remaining arguments deal with setting the mipmap level of detail (2nd argument), specifying the internal format (e.g., 3rd argument’s <span class="code">GL_RGB</span>) and whether the texture has a border or not (6th argument). When learning OpenGL textures it is safe to keep these as the defaults listed here. However, the reader is advised to learn more about mipmaps and the potential internal formats of textures as more advanced graphics processing is required.</p>
<p>Texture object allocation and initialization happens with the code above. Additional modifications must be made to vertex buffers and vertex array objects to link in the correct texture coordinates with the geometric description. Following the previous examples, the storage for texture coordinates is a straightforward modification to the vertex data structure:</p>
<pre><span class="code">struct vertexData</span></pre>
<pre><span class="code">{</span></pre>
<pre><span class="code"> glm::vec3 pos;</span></pre>
<pre><span class="code"> glm::vec3 normal;</span></pre>
<pre><span class="code"> glm::vec2 texCoord;</span></pre>
<pre><span class="code">};</span></pre>
<p>As a result, the vertex buffer object will increase in size and the interleaving of texture coordinates will require a change to the stride in the vertex attribute specification for the vertex array objects. <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-10">Figure 17.10</a> illustrates the basic interleaving of data within the vertex buffer.</p>
<div id="art_Dest_fig_17-10" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-10"></a><span class="cBold">Figure 17.10</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-10.png" alt="Figure showing data layout after adding the texture coordinate to the vertex buffer. Each block represents a GLfloat, which is 4 bytes. The position is encoded as a white block, the normals as purple, and the texture coordinates as orange." width="600" height="78" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-10.png"></p>
<p class="Text figcaption">Data layout after adding the texture coordinate to the vertex buffer. Each block represents a GLfloat, which is 4 bytes. The position is encoded as a white block, the normals as purple, and the texture coordinates as orange.</p>
</div>
<pre><span class="code">glBindBuffer(GL_ARRAY_BUFFER, m_triangleVBO[0]);</span></pre>
<pre></pre>
<pre><span class="code">glEnableVertexAttribArray(0);</span></pre>
<pre><span class="code">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), 0);</span></pre>
<pre></pre>
<pre><span class="code">glEnableVertexAttribArray(1);</span></pre>
<pre><span class="code">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (const GLvoid *)12);</span></pre>
<pre></pre>
<pre><span class="code">glEnableVertexAttribArray(2);</span></pre>
<pre><span class="code">glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (const GLvoid *)24);</span></pre>
<pre></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<p><a id="page_472"></a>With the code snippet above, the texture coordinates are placed at vertex attribute location 2. Note the change in size of the texture coordinate’s size (e.g., 2nd argument of <span class="code">glVertexAttribPointer</span> is 2 for texture coordinates to coincide with the <span class="code">vec2</span> type in the structure). At this point, all initialization will have been completed for the texture object.</p>
<p>The texture object must be enabled (or bound) prior to rendering the vertex array object with your shaders. In general, graphics hardware allows the use of multiple texture objects when executing a shader program. In this way, shader programs can apply sophisticated texturing and visual effects. Thus, to bind a texture for use with a shader, it must be associated to one of potentially many <span class="cItalic">texture units.</span> Texture units represent the mechanism by which shaders can use multiple textures. In the sample below, only one texture is used so texture unit 0 will be made active and bound to our texture.</p>
<p>The function that activates a texture unit is <span class="code">glActiveTexture</span>. Its only argument is the texture unit to make active. It is set to <span class="code">GL_TEXTURE0</span> below, but it could be <span class="code">GL_TEXTURE1</span> or <span class="code">GL_TEXTURE2</span>, for instance, if multiple textures were needed in the shader. Once a texture unit is made active, a texture object can be bound to it using the <span class="code">glBindTexture</span> call.</p>
<div class="Box">
<pre><span class="code">glUseProgram(shaderID);</span></pre>
<pre></pre>
<pre><span class="code">glActiveTexture(GL_TEXTURE0);</span></pre>
<pre><span class="code">glBindTexture(GL_TEXTURE_2D, texID);</span></pre>
<pre><span class="code">glUniform1i(texUnitID, 0);</span></pre>
<pre></pre>
<pre><span class="code">glBindVertexArray(VAO);</span></pre>
<pre><span class="code">glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre>
<pre><span class="code">glBindVertexArray(0);</span></pre>
<pre></pre>
<pre><span class="code">glBindTexture(GL_TEXTURE_2D, 0);</span></pre>
<pre></pre>
<pre><span class="code">glUseProgram(0);</span></pre>
</div>
<p>Most of the code above should be logical extensions to what you’ve developed thus far. Note the call to <span class="code">glUniform</span> prior to rendering the vertex array object. In modern graphics hardware programming, shaders perform the work of texture lookups and blending, and therefore, must have data about which texture units hold the textures used in the shader. The active texture units are supplied to shaders using uniform variables. In this case, 0 is set to indicate that the texture lookups will come from texture unit 0. This will be expanded upon in the following section.</p>
<h3><a id="page_473"></a><a id="sec17-15-1"></a>17.15.1 Texture Lookup in Shaders</h3>
<p>Shader programs perform the lookup and any blending that may be required. The bulk of that computation typically goes into the fragment shader, but the vertex shader often stages the fragment computation by passing the texture coordinate out to the fragment shader. In this way, the texture coordinates will be interpolated and afford per-fragment lookup of texture data.</p>
<p>Simple changes are required to use texture data in shader programs. Using the Blinn-Phong vertex shader provided previously, only three changes are needed:</p>
<ol>
<li class="LX">The texture coordinates are a per-vertex attribute stored within the vertex array object. They are associated with vertex attribute index 2 (or location 2).
<pre><span class="code">layout(location=2) in vec2 in_TexCoord;</span></pre>
</li>
<li class="LX">The fragment shader will perform the texture lookup and will need an interpolated texture coordinate. This variable will be added as an output variable that gets passed to the fragment shader.
<pre><span class="code">out vec2 tCoord;</span></pre>
</li>
<li class="LX">Copy the the incoming vertex attribute to the output variable in the main function.
<pre><span class="code">// Pass the texture coordinate to the fragment shader tCoord = in_TexCoord;</span></pre>
</li>
</ol>
<p>The fragment shader also requires simple changes. First, the incoming interpolated texture coordinates passed from the vertex shader must be declared. Also recall that a uniform variable should store the texture unit to which the texture is bound. This must be communicated to the shader as a <span class="cItalic">sampler</span> type. Samplers are a shading language type that allows the lookup of data from a single texture object. In this example, only one sampler is required, but in shaders in which multiple texture lookups are used, multiple sampler variables will be used. There are also multiple sampler types depending upon the type of texture object. In the example presented here, a <span class="code">GL_TEXTURE_2D</span> type was used to create the texture state. The associated sampler within the fragment shader is of type <span class="code">sampler2D</span>. The following two variable declarations must be added to the fragment shader:</p>
<pre><span class="code">in vec2 tCoord;</span></pre>
<pre><span class="code">uniform sampler2D textureUnit;</span></pre>
<p><a id="page_474"></a>The final modification goes into the main function of the fragment shader code. The <span class="code">texture</span> is sampled using the GLSL texture lookup function and (in this case), replaces the diffuse coefficient of the geometry. The first argument to <span class="code">texture</span> takes the sampler type which holds the texture unit to which the texture is bound. The second argument is the texture coordinate. The function returns a <span class="code">vec4</span> type. In the code snippet below, no alpha values are utilized in the final computation so the resulting texture lookup value is component-wise selected to only the RGB components. The diffuse coefficient from the texture lookup is set to a <span class="code">vec3</span> type that is used in the illumination equation.</p>
<pre><span class="code">vec3 kdTexel = texture(textureUnit, tCoord).rgb;</span></pre>
<pre><span class="code">vec3 intensity = ka * Ia + kdTexel * light.intensity</span></pre>
<pre><span class="code">    * max(0.0, dot(n, l)) + ks * light.intensity</span></pre>
<pre><span class="code">    * pow(max(0.0, dot(n, h)), phongExp);</span></pre>
<p><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-11">Figure 17.11</a> illustrates the results of using these shader modifications. The right-most image in the figure extends the example code by enabling texture tiling with the OpenGL state. Note that these changes are only done in host code and the shaders do not change. To enable this tiling, which allows for texture coordinates outside of the device normalized ranges, the texture parameters for <span class="code">GL_TEXTURE_WRAP_S</span> and <span class="code">GL_TEXTURE_WRAP_T</span> are changed from <span class="code">GL_CLAMP</span> to <span class="code">GL_REPEAT</span>. Additionally, the host code that sets the texture coordinates now ranges from [0, 5].</p>
<div id="art_Dest_fig_17-11" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-11"></a><span class="cBold">Figure 17.11</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-11.png" alt="Figure showing the left-most image shows the texture, a 1024 × 1024 pixel image. The middle image shows the scene with the texture applied using texture coordinates in the range of [0, 1] so that only one image is tiled onto the ground plane. The right-most image modifies the texture parameters so that GL_REPEAT is used for GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T and the texture coordinate range from [0, 5]. The result is a tiled texture repeat five times in both texture dimensions." width="600" height="197" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-11.png"></p>
<p class="Text figcaption">The left-most image shows the texture, a 1024 × 1024 pixel image. The middle image shows the scene with the texture applied using texture coordinates in the range of [0, 1] so that only one image is tiled onto the ground plane. The right-most image modifies the texture parameters so that <span class="code">GL_REPEAT</span> is used for <span class="code">GL_TEXTURE_WRAP_S</span> and <span class="code">GL_TEXTURE_WRAP_T</span> and the texture coordinate range from [0, 5]. The result is a tiled texture repeat five times in both texture dimensions.</p>
</div>
<p>As a side note, another texture target that may be useful for various applications is the <span class="code">GL_TEXTURE_RECTANGLE</span>. Texture rectangle are unique texture objects that are not constrained with the power-of-two width and height image requirements and use non-normalized texture coordinates. Furthermore, they do<a id="page_475"></a> not allow repeated tiling. If texture rectangles are used, shaders must reference them using the special sampler type: <span class="code">sampler2DRect</span>.</p>
<h2><a id="sec17-16"></a>17.16 Object-Oriented Design for Graphics Hardware Programming</h2>
<p>As your familiarity with OpenGL increases, it becomes wise to encapsulate most of what is described in this chapter into class structures that can contain the model specific data and afford rendering of a variety of objects within the scene. For instance, in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-12">Figure 17.12</a>, a single sphere is instanced six times to create the three ellipsoids and three spheres. Each model uses the same underlying geometry yet has different material properties and model transforms. If you’ve followed through the book and implemented the ray tracer, as detailed in <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C004.xhtml">Chapter 4</a>, then it is likely that your implementation is based on a solid object-oriented design. That design can be leveraged to make developing a graphics hardware program with OpenGL easier. A typical ray tracer software architecture will include several classes that map directly into graphics hardware as well as software rasterization applications. The abstract base classes in the ray tracer that represent surfaces, materials, lights, shaders, and cameras can be adapted to initialize the graphics hardware state, update that state, and if necessary render the class data to the framebuffer. The interfaces to these virtual functions will likely need to be<a id="page_476"></a> adapted to your specific implementation, but a first pass that extends the surface class design might resemble the following:</p>
<div id="art_Dest_fig_17-12" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-12"></a><span class="cBold">Figure 17.12</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-12.png" alt="Figure showing on the left, a single tessellated sphere is instanced six times using different model transforms to create this scene using the per-fragment shader program. The image on the right is rendered using a basic Whitted ray tracer. Notice the effect that shadows have on the perception of the scene. Per-fragment shading allows the specular highlight to be similar in both rendering styles." width="600" height="298" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-12.png"></p>
<p class="Text figcaption">On the left, a single tessellated sphere is instanced six times using different model transforms to create this scene using the per-fragment shader program. The image on the right is rendered using a basic Whitted ray tracer. Notice the effect that shadows have on the perception of the scene. Per-fragment shading allows the specular highlight to be similar in both rendering styles.</p>
</div>
<pre><span class="code">class surface</span></pre>
<pre><span class="code">virtual bool initializeOpenGL()</span></pre>
<pre><span class="code">virtual bool renderOpenGL(glm::mat4&amp; <span class="cBold">M</span><span class="cSubscript">p</span>, glm::mat4&amp; <span class="cBold">M</span><span class="cSubscript">cam</span>)</span></pre>
<p>Passing the projection and view matrices to the render functions affords an indirection for how these matrices are managed. These matrices would come from the camera classes which may be manipulated by interpreting keyboard, mouse, or joystick input. The initialization functions (at least for the surface derivatives) would contain the vertex buffer object and vertex array object allocation and initialization code. Aside from initiating the draw arrays for any vertex array objects, the render function would also need to activate shader programs and pass in the necessary matrices into the shaders, as illustrated previously in the dragon model example. As you work to integrate the image-order and object-order (hardware and software) algorithms into the same underlying data framework, a few software design challenges will pop up, mostly related to data access and organization. However, this is a highly useful exercise to become adept at software engineering for graphics programming and eventually gain solid experience hybridizing your rendering algorithms.</p>
<h2><a id="sec17-17"></a>17.17 Continued Learning</h2>
<p>This chapter was designed to provide an introductory glimpse into graphics hardware programming, influenced by the OpenGL API. There are many directions that your continued learning could go. Many topics, such as framebuffer objects, render to texture, environment mapping, geometry shaders, compute shaders, and advanced illumination shaders were not covered. These areas represent the next stages in learning about graphics hardware, but even within the areas covered, there are many directions that one could go to develop stronger graphics hardware understanding. Graphics hardware programming will continue to evolve and change. Interested readers should expect these changes and look to the specification documents for OpenGL and the OpenGL Shading Language for many more details about what OpenGL is capable of doing and how the hardware relates to those computations.</p>
<h2><a id="sec17-18"></a><a id="page_477"></a>Frequently Asked Questions</h2>
<ul>
<li class="LX"><p><span class="cBold">How do I debug shader programs?</span></p>
<p>On most platforms, debugging both vertex shaders and fragment shaders is not simple. However, more and more support is available through various drivers, operating system extensions, and IDEs to provide pertinent information to the developer. It still can be challenging, so use the shaders to visually debug your code. If nothing comes up on the screen, try rendering the normal vectors, the half vector, or anything that give you a sense for where the error might be (or not be). <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-13">Figure 17.13</a> illustrates a normal shader in operation. If images do appear on your window, make sure they are what you expect (refer to <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#Text_Anchor_fig_17-14">Figure 17.14</a>)!</p></li>
</ul>
<div id="art_Dest_fig_17-13" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-13"></a><span class="cBold">Figure 17.13</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-13.png" alt="Figure showing applying the normal shader to a complex model for debugging purposes." width="405" height="404" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-13.png"></p>
<p class="Text figcaption">Applying the normal shader to a complex model for debugging purposes.</p>
</div>
<div id="art_Dest_fig_17-14" class="ArtGroup">
<p class="Text fignumber"><a id="Text_Anchor_fig_17-14"></a><span class="cBold">Figure 17.14</span></p>
<p class="ObjectLine"><img src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/fig17-14.png" alt="Figure showing visual debugging is important! Can you figure out what is wrong from the image or where to start debugging? When the incorrect stride is applied to the vertex array object, rendering goes awry." width="405" height="404" data-mfp-src="/library/view/fundamentals-of-computer/9781482229417/image/fig17-14.png"></p>
<p class="Text figcaption">Visual debugging is important! Can you figure out what is wrong from the image or where to start debugging? When the incorrect stride is applied to the vertex array object, rendering goes awry.</p>
</div>
<h2><a id="sec17-19"></a>Notes</h2>
<p>There are many good resources available to learn more about the technical details involved with programming graphics hardware. A good starting point might be the OpenGL and GLSL specification documents. They are available for free online at the opengl.org website. These documents will provide complete details for all the different and emerging versions of OpenGL.</p>
<h2><a id="sec17-20"></a>Exercises</h2>
<p>The sections of this chapter are roughly organized to step students through the process of creating a modern OpenGL application. Some extra effort will be required to understand the details relating to setting up windows and OpenGL contexts. However, it should be possible to following the sections for a set of weekly one hour labs:</p>
<ol>
<li class="LX"><span class="cBold">Lab 1: Basic code setup for OpenGL applications.</span> This includes installing the necessary drivers and related software such as GLM and GLFW. Students can then write code to open a window and clear the color buffers.</li>
<li class="LX"><span class="cBold">Lab 2: Creating a shader.</span> Since a rudimentary shader is necessary to visualize the output in modern OpenGL, starting with efforts to create a very basic shader will go a long way. In this lab, or labs, students could build (or use provided) classes to load, compile, and link shaders into shader programs.</li>
<li class="LX"><a id="page_478"></a><span class="cBold">Lab 3: Create a clip coordinate triangle and shade.</span> Using the shader classes from the previous lab, students will add the passthrough shader and create simple geometry to render.</li>
<li class="LX"><span class="cBold">Lab 4: Introduce GLM.</span> Start using GLM to generate projection matrices and viewing matrices for viewing more generalized, yet simple, scenes.</li>
<li class="LX"><span class="cBold">Lab 5: Use GLM for local transformations.</span> Students can expand their working shader program to use local transforms, perhaps applying animations based on changing transforms.</li>
<li class="LX"><span class="cBold">Lab 6: Shader development.</span> Develop the Lambertian or Blinn-Phong shaders.</li>
<li class="LX"><span class="cBold">Lab 7: Work with materials.</span> Students can explore additional material properties and rendering styles with different shader programs.</li>
<li class="LX"><span class="cBold">Lab 8: Load 3D models.</span> Using code to load OBJ files, students can further explore the capabilities of their graphics hardware including the limits of hardware processing for real-time applications.</li>
<li class="LX"><span class="cBold">Lab 9: Textures.</span> Using PNG (or other formats), students can load images onto the hardware and practice a variety of texture-mapping strategies.</li>
<li class="LX"><span class="cBold">Lab 10: Integration with rendering code.</span> If scene files are used to describe scenes for the ray tracer (or rasterizer), students’ OpenGL code can be integrated into a complete rendering framework using common structures and classes to build a complete system.</li>
</ol>
<p>This list is only a guide. In labs for my computer graphics course, students are provided material to get them started on the week’s idea. After they get the basic idea working, the lab is completed once they add their spin or a creative exploration of the idea to their code. As students get familiar with graphics hardware programming, they can explore additional areas of interest, such as textures, render to texture, or more advanced shaders and graphics algorithms.</p>
<div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-14" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#">Add Highlight</a></li>
		<li class="add-note"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#">
			
				Add Note
			
		</a></li>
		
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C016.xhtml" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 16 Computer Animation</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C018.xhtml" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 18 Light</div>
        </a>
    
  
  </div>

</section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag collapsed slideUp">
        
        
          
          
            <p class="usage-data">Find answers on the fly, or master something new. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
          

          
        
        

      </div>

    
    



        
      </div>
      




  <footer class="pagefoot t-pagefoot" style="padding-bottom: 69px;">
    <a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" class="icon-up" style="display: none;"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://learning.oreilly.com/r/">Recommended</a></li>
      
      <li>
      <a class="t-queue-footer" href="https://learning.oreilly.com/playlists/">Playlists</a>
      </li>
      
        <li><a class="t-recent-footer" href="https://learning.oreilly.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://learning.oreilly.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://learning.oreilly.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://learning.oreilly.com/u/preferences/">Settings</a></li>
      <li class="full-support"><a href="https://www.oreilly.com/online-learning/support/">Support</a></li>
      <li><a href="https://learning.oreilly.com/online-learning/apps.html">Get the App</a></li>
      <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2019 <a href="https://learning.oreilly.com/" target="_blank">Safari</a>.</span>
    <a href="https://learning.oreilly.com/terms/">Terms of Service</a> /
    <a href="https://learning.oreilly.com/privacy.html">Privacy Policy</a>
  </footer>

<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"licenseKey":"510f1a6865","errorBeacon":"bam.nr-data.net","transactionName":"YgdaZ0NSW0cEB0RdWltNfkZfUEFdCgofXFBHDVYdR1pQQxZeRl1QQj1aWkU=","beacon":"bam.nr-data.net","queueTime":2,"applicationID":"3275661,67267027,67267028","applicationTime":155,"agent":""}</script>


    
    <script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/saved_resource" charset="utf-8"></script>
<script type="text/javascript" id="">(function(){function b(){!1===c&&(c=!0,Munchkin.init("107-FMS-070"))}var c=!1,a=document.createElement("script");a.type="text/javascript";a.async=!0;a.src="//munchkin.marketo.net/munchkin.js";a.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||b()};a.onload=b;document.getElementsByTagName("head")[0].appendChild(a)})();</script><script type="text/javascript" id="">(function(){window.medalliaUserIdentifier=document.documentElement.dataset.userUuid;window.medalliaUserName=document.documentElement.dataset.username})();</script>
<script type="text/javascript" id="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/embed.js.download"></script><script type="text/javascript" id="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/digitalpi-utm-tracker-oreilly.com.js.download"></script><script type="text/javascript" id="">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","https://connect.facebook.net/en_US/fbevents.js");fbq("init","1732687426968531");fbq("track","PageView");</script>
<noscript><img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=1732687426968531&amp;ev=PageView&amp;noscript=1"></noscript><div style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.3614381240402751"><img style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.7124633219858325" width="0" height="0" alt="" src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/0"></div>



    <script src="./Chapter 17 Using Graphics Hardware - Fundamentals of Computer Graphics, 4th Edition_files/saved_resource(1)" charset="utf-8"></script>
  

<div class="annotator-notice"></div><div class="font-flyout" style="top: 201.003px; left: 1818px;"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://learning.oreilly.com/library/view/fundamentals-of-computer/9781482229417/K22616_C017.xhtml#">Reset</a>
</div>
</div><div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_SansSerif-italic, sans-serif;"></div></div></body></html>